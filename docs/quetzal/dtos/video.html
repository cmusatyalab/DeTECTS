<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>quetzal.dtos.video API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>quetzal.dtos.video</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
import os
import re
import threading
from glob import glob
from os.path import join
from typing import Literal, List
from typing import NewType, Union
from pathlib import Path
import importlib

import cv2
import numpy as np
import natsort
import shutil

from quetzal.engines.engine import AbstractEngine
from quetzal.dtos.dtos import QuetzalFile, Permission, FileType, AnalysisProgress, AccessMode
from quetzal.utils.video_tools import extract_frames
import torch

logging.basicConfig()

Resolution = NewType(&#34;Resolution&#34;, int)
Fps = NewType(&#34;Fps&#34;, int)

DATABASE_ROOT = &#34;database&#34;
QUERY_ROOT = &#34;query&#34;
reserved_names = [DATABASE_ROOT, QUERY_ROOT]

def extract_fps_res(directory_name: str) -&gt; Union[tuple[Fps, Resolution], tuple[None, None]]:
    &#34;&#34;&#34;
    Extracts frames per second (fps) and resolution from a directory name.

    Args:
        directory_name (str): The directory name from which to extract the fps and resolution.

    Returns:
        tuple: A tuple (fps, resolution) if extraction is successful, otherwise (None, None).
    &#34;&#34;&#34;

    # Regular expression to match &#39;frames_{fps}_{resolution}&#39;
    pattern = re.compile(r&#34;frames_(\d+)_(\d+)&#34;)
    match = pattern.search(directory_name)
    if match:
        fps = int(match.group(1))
        resolution = int(match.group(2))
        return fps, resolution
    else:
        print(f&#34;Invalid directory name: {directory_name}&#34;)
        return None, None

def frame_count(fp: str) -&gt; str:
    &#34;&#34;&#34;
    Reads the number of frames from a file.

    Args:
        fp (str): File path containing the frame count.

    Returns:
        int: The number of frames.
    &#34;&#34;&#34;
    return int(open(fp, &#34;r&#34;).read().strip())


# VideoTypes: TypeAlias = Literal[*reserved_names]

class Video(QuetzalFile):
    &#34;&#34;&#34;
    Represents a video file within the Quetzal system, capable of processing drone footage.

    Attributes:
        video_type (Literal[&#34;database&#34;, &#34;query&#34;]): Specifies the type of the video, indicating
            its role within the dataset as either a reference (database) or subject (query) video.
        fps (Fps): Frames per second at which the video is processed.
        resolution (Resolution): Resolution at which the video frames are processed.
    &#34;&#34;&#34;
    
    FILE_DEFAULT_DESCRIPTION = &#34;Uploader::= default\nRecorded Date (MM/DD/YYYY)::= default\nTime-of-day::= default\nWeather Condition::= default\nDescription::= default&#34;
    FILE_DEFAULT_META = &#34;FileType::= file\nVisibility::= private\nPermission::= full_write\nAnalysisProgress::= none\nSpecificType::=Video\n&#34;
        
    def __init__(
        self,
        path: Union[str, Path],
        root_dir: Union[str, Path],
        metadata_dir: Union[str, Path],        
        user: str = None,
        home: Union[str, Path] = &#34;./&#34;,
        metadata = None,
        parent: &#39;QuetzalFile&#39; = None,
        video_type: Literal[&#34;database&#34;, &#34;query&#34;] = &#34;query&#34;,
        fps: Fps = 2,
        resolution: Resolution = 1024,
    ):
        &#34;&#34;&#34;
        Initializes a Video object.

        Args:
            path: The path to the video file, relative to `root_dir`.
            root_dir: The root directory for datasets.
            metadata_dir: The root directory for metadata.
            user: The user associated with the video file. Defaults to a guest user.
            home: The base home directory path. Defaults to &#34;./&#34;.
            metadata: Metadata associated with the video file.
            parent: The parent QuetzalFile object, if applicable.
            video_type: The type of the video, either &#39;database&#39; or &#39;query&#39;. Defaults to &#39;query&#39;.
            fps: The frames per second at which the video is processed. Defaults to 2.
            resolution: The resolution at which the video frames are processed. Defaults to 1024.
        &#34;&#34;&#34;
        super().__init__(
            path=path,
            root_dir=root_dir,
            metadata_dir=metadata_dir,
            user=user,
            home=home,
            metadata=metadata,
            parent=parent
        )
        
        assert video_type in [
            &#34;database&#34;,
            &#34;query&#34;,
        ], &#34;video_type must be &#39;database&#39; or &#39;query&#39;&#34;
        
        self._video_type = video_type
        self._fps = fps
        self._resolution = resolution
        
        self._gps = None
        self.logger = logging.getLogger(&#34;Video_&#34; + self._path.name)
        self.logger.setLevel(logging.DEBUG)
        self.debug = lambda *args: self.logger.debug(&#34; &#34;.join([str(arg) for arg in args]))

        self._lock = threading.RLock()
        self._cam = None
        self._native_fps = None
        self._orig_width, self._orig_height = None, None
        
        self._video_start = 0
        self._video_end = None
        
    
    def load_video_info(self):
        &#34;&#34;&#34;
        Loads video information such as native frames per second (fps), original width, and height from the video file. Initializes the video capture object.

        Raises:
            ValueError: If the video file cannot be opened.
        &#34;&#34;&#34;
        # Initialize the camera and check if it&#39;s a valid video file
        self._cam = cv2.VideoCapture(str(self.full_path))
        if not self._cam.isOpened():
            raise ValueError(f&#34;Failed to open video file: {self.full_path}&#34;)

        self._native_fps = self._cam.get(cv2.CAP_PROP_FPS)
        self._orig_width, self._orig_height = int(self._cam.get(3)), int(self._cam.get(4))
        
    @property
    def fps(self) -&gt; Fps:
        &#34;&#34;&#34;
        Gets the frames per second (fps) at which the video is processed.

        Returns:
            Fps: The current fps setting for video processing.
        &#34;&#34;&#34;
        return self._fps
    
    @fps.setter
    def fps(self, value: Fps):
        &#34;&#34;&#34;
        Sets the frames per second (fps) for video processing.

        Args:
            value (Fps): The new fps setting.
        &#34;&#34;&#34;
        self._fps = value
    
    @property
    def resolution(self) -&gt; Resolution:
        &#34;&#34;&#34;
        Gets the resolution at which the video frames are processed.

        Returns:
            Resolution: The current resolution setting for video processing.
        &#34;&#34;&#34;
        return self._resolution
    
    @resolution.setter
    def resolution(self, value: Resolution):
        &#34;&#34;&#34;
        Sets the resolution for video processing.

        Args:
            value (Resolution): The new resolution setting.
        &#34;&#34;&#34;
        self._resolution = value
    
    @property
    def video_type(self) -&gt; Literal[&#34;database&#34;, &#34;query&#34;] :
        &#34;&#34;&#34;
        Gets the type of the video, indicating whether it&#39;s used as reference (database) or subject (query).

        Returns:
            Literal[&#34;database&#34;, &#34;query&#34;]: The current video type setting.
        &#34;&#34;&#34;
        return self._video_type
    
    @video_type.setter
    def video_type(self, value: Literal[&#34;database&#34;, &#34;query&#34;] ):
        &#34;&#34;&#34;
        Sets the type of the video to either &#39;database&#39; or &#39;query&#39;.

        Args:
            value (Literal[&#34;database&#34;, &#34;query&#34;]): The new video type setting.
        &#34;&#34;&#34;
        self._video_type = value
        
    @property
    def _dataset_dir(self) -&gt; Path:
        &#34;&#34;&#34;
        Internal method to construct the dataset directory path based on the video type and file path.

        Returns:
            Path: The dataset directory path.
        &#34;&#34;&#34;
        if self._metadata_dir:
            return self._metadata_dir / self._path.parent / self._video_type / self._path.stem
        else:
            return self._root_dir / self._path.parent / self._video_type / self._path.stem
        
    @property
    def dataset_dir(self) -&gt; Path:
        &#34;&#34;&#34;
        Constructs the complete dataset directory path including frames configuration (fps and resolution).

        Returns:
            Path: The complete dataset directory path for storing frames.
        &#34;&#34;&#34;
        return self._dataset_dir / f&#34;frames_{self._fps}_{self._resolution}&#34;
    
    
    @property
    def avaliable_frames(self) -&gt; list[tuple[Fps, Resolution]]:
        &#34;&#34;&#34;
        Checks the availability of different combinations of fps and resolution for which the frames are extracted.

        Returns:
            list[tuple]: A list of tuples (fps, resolution) available in the dataset.
        &#34;&#34;&#34;
        dir_list = [
            d
            for d in os.listdir(self._dataset_dir)
            if os.path.isdir(join(self._dataset_dir, d))
        ]

        if len(dir_list) == 0:
            return []

        return [
            extract_fps_res(str(dir))
            for dir in dir_list
            if self.is_dir_valid(join(self._dataset_dir, dir))
        ]
    
    
    @property
    def frame_len(self) -&gt; int:
        &#34;&#34;&#34;
        Retrieves the total number of frames in the dataset directory.

        Returns:
            int: The number of frames, or -1 if the frame count is not available.
        &#34;&#34;&#34;

        target_dir = self.dataset_dir
        frame_count_file = join(target_dir, &#34;frame_counts.txt&#34;)

        with self._lock:
            if os.path.exists(frame_count_file):
                return frame_count(frame_count_file)
            else:
                return -1
    

    @staticmethod
    def get_frame_list(dir: str) -&gt; List[str]:
        &#34;&#34;&#34;
        Get a list of frame file paths from a directory.

        Args:
            dir (str): The directory to search for frame files.

        Returns:
            List[str]: A list of file paths for each frame in the directory.
        &#34;&#34;&#34;
        files = glob(join(dir, f&#34;frame*.jpg&#34;))
        pattern = re.compile(r&#34;frame(\d{5})\.jpg&#34;)
        return [f for f in files if pattern.search(f)]

    def get_frame_idx(self, frame_path: str) -&gt; int:
        &#34;&#34;&#34;
        Extracts the frame index from a frame file path.

        Args:
            frame_path (str): The file path of the frame.

        Returns:
            int: The index of the frame.
        &#34;&#34;&#34;

        frame_number_str = frame_path[-9:-4]  # Assuming 5-digit frame number
        return int(frame_number_str) - 1

    def get_frame_idx_at_time(self, frame_time: float) -&gt; int:
        &#34;&#34;&#34;
        Gets the frame index at a specific time in the video.

        Args:
            frame_time (float): The time in seconds.

        Returns:
            int: The frame index corresponding to the given time.
        &#34;&#34;&#34;
        return int(frame_time * self._fps + 0.5)

    def get_frame_time(self, frame_index: int) -&gt; float:
        &#34;&#34;&#34;
        Converts a frame index to a time point in the video.

        Args:
            frame_index (int): The index of the frame.

        Returns:
            float: Time in seconds where the frame is located in the video.
        &#34;&#34;&#34;
        return frame_index / self._fps

    def get_raw_frame_at(self, idx: int) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Retrieves the raw frame at a given index from the video.

        Args:
            idx (int): The frame index.

        Returns:
            ndarray: The raw frame as a numpy array in RGB format, or None if retrieval fails.
        &#34;&#34;&#34;
        if self._cam is None:
            self.load_video_info()

        orig_frame_idx = int(idx / self._fps * self._native_fps + 0.5)
        self._cam.set(cv2.CAP_PROP_POS_FRAMES, orig_frame_idx)
        rv, frame = self._cam.read()

        if rv:
            return cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        else:
            return None

    def set_video_start(self, minute: int, sec: int):
        &#34;&#34;&#34;
        Sets the starting point for video processing based on a specific time given in minutes and seconds.

        Args:
            minute (int): The starting minute in the video.
            sec (int): The starting second in the video.
        &#34;&#34;&#34;
        

        if not (minute &gt;= 0 and sec &gt;= 0):
            logging.error(&#34;Video-start should be positive time&#34;)
            return

        sec = 60 * minute + sec
        index = sec * self._fps
        self._video_start = index

    def set_video_end(self, minute: int, sec: int):
        &#34;&#34;&#34;
        Sets the ending point for video processing based on a specific time given in minutes and seconds.

        Args:
            minute (int): The ending minute in the video.
            sec (int): The ending second in the video.
        &#34;&#34;&#34;

        if not (minute &gt;= 0 and sec &gt;= 0):
            logging.error(&#34;Video-end should be positive time&#34;)
            return

        sec = 60 * minute + sec
        index = sec * self._fps
        if index &gt; self._video_start:
            self._video_end = index
        else:
            minute = int(self._video_start / self._fps / 60)
            sec = int(self._video_start / self._fps) % 60
            logging.error(
                f&#34;Video-end Should be greator than video-start = {minute}:{sec}&#34;
            )
            self._video_end = None

    def get_video_start_idx(self) -&gt; int:
        &#34;&#34;&#34;
        Gets the starting frame index of the video for processing.

        Returns:
            int: The starting frame index.
        &#34;&#34;&#34;
        return self._video_start

    def get_video_end_idx(self) -&gt; int:
        &#34;&#34;&#34;
        Gets the ending frame index of the video for processing.

        Returns:
            int: The ending frame index, or None if not set.
        &#34;&#34;&#34;
        return self._video_end


    def is_dir_valid(self, dir: Union[str, Path]) -&gt; bool:
        &#34;&#34;&#34;
        Validates if the specified directory contains a valid set of extracted frames and matches the recorded frame count.

        Args:
            dir (Union[str, Path]): The directory to validate.

        Returns:
            bool: True if the directory contains a valid set of frames, False otherwise.
        &#34;&#34;&#34;

        if not os.path.isdir(dir):
            return False

        frame_count_file = join(dir, &#34;frame_counts.txt&#34;)
        if os.path.exists(frame_count_file):
            if len(Video.get_frame_list(dir)) == frame_count(frame_count_file):
                return True
        return False

    def get_frames(self, verbose: bool = True) -&gt; List[str]:
        &#34;&#34;&#34;
        Retrieves or generates frames for the video at the current fps and resolution settings.

        Args:
            verbose (bool, optional): If True, logs additional information. Defaults to True.

        Returns:
            list: A list of frame file paths.
        &#34;&#34;&#34;

        fps = self._fps
        resolution = self._resolution

        target_dir = self.dataset_dir
        frame_count_file = target_dir / &#34;frame_counts.txt&#34;

        loaded = False
        with self._lock:
            if not self.is_dir_valid(target_dir):
                if verbose:
                    self.logger.info(
                        f&#34;Frames in fps={fps}, res={resolution} do not exist. Generating...&#34;
                    )
                os.makedirs(target_dir, exist_ok=True)
                input_frames = extract_frames(
                    self.full_path, target_dir, max_size=resolution, fps=fps
                )
                with open(frame_count_file, &#34;w&#34;) as f:
                    f.write(str(len(input_frames)))

                loaded = True

        if not loaded:
            if verbose:
                self.logger.info(
                    f&#34;Frames in fps={fps}, res={resolution} found in the dataset.&#34;
                )
            input_frames = Video.get_frame_list(target_dir)

        # self.frame_len = len(input_frames)
        idx_start = self._video_start
        if self._video_end == None:
            idx_end = len(input_frames)
        else:
            idx_end = self._video_end
        return natsort.natsorted(input_frames)[
            idx_start : min(idx_end, len(input_frames))
        ]    
        
    def _renameAnalysisData(self, newName: Path):
        &#34;&#34;&#34;
        Rename analysis data associated with the video, including updating paths of analysis data directories to reflect the new video name.

        Args:
            newName (Path): The new name for the video, used to update analysis data directories.
        &#34;&#34;&#34;
        for data_dir in reserved_names:
            analysis_path = (
                self._metadata_dir / self._path.parent / data_dir / self._path.stem
            )

            if analysis_path.exists():
                new_path = (
                    self._metadata_dir / self._path.parent / data_dir / newName.stem
                )
                os.rename(analysis_path, new_path)
    
    def _updateMetaForRename(self, new_path):
        &#34;&#34;&#34;
        Overrides the superclass method to update metadata and analysis data for the video in response to renaming. Ensures consistency between the video file&#39;s metadata and its analysis data following a name change.

        Args:
            new_path (Path): The new path for the video file, reflecting its new name.
        &#34;&#34;&#34;
        self._renameAnalysisData(new_path)
        super()._updateMetaForRename(new_path)
    
    
    def _deleteAnalysisData(self):
        &#34;&#34;&#34;
        Delete all analysis data associated with the video. Ensures that orphaned analysis data is removed when a video file is deleted from the system.
        &#34;&#34;&#34;
        for data_dir in [DATABASE_ROOT, QUERY_ROOT]:
            analysis_path = (
                self._metadata_dir / self._path.parent / data_dir / self._path.stem
            )

            if analysis_path.exists():
                shutil.rmtree(analysis_path)
                
    def _updateMetaForDelete(self):
        &#34;&#34;&#34;
        Overrides the superclass method to update the video&#39;s metadata to reflect its deletion, including removing all references to the video and its analysis data.
        &#34;&#34;&#34;
        self._deleteAnalysisData()
        super()._updateMetaForDelete()
        
    
    def _copyAnalysisData(self, newDir: Path, destName: Path, move=False):
        &#34;&#34;&#34;
        Copy or move the analysis data associated with the video. Supports video copy or move operations by maintaining the integrity of analysis data.

        Args:
            newDir (Path): Directory to which the analysis data will be copied or moved.
            destName (Path): Name of the destination directory or file.
            move (bool, optional): If True, analysis data is moved; otherwise, it is copied. Defaults to False.
        &#34;&#34;&#34;
        
        for data_dir in [&#34;database&#34;, &#34;query&#34;]:
            analysis_path = (
                self._metadata_dir / self._path.parent / data_dir / self._path.stem
            )
            if analysis_path.exists():
                copy_path = self._metadata_dir / newDir / data_dir / destName.stem
                if move:
                    shutil.move(analysis_path, copy_path)
                else:
                    shutil.copytree(analysis_path, copy_path)
    
    def _updateMetaForCopy(self, dest: Path):
        &#34;&#34;&#34;
        Overrides the superclass method to update metadata for a video after copying. Includes copying the analysis data to the new location and updating the video&#39;s metadata.

        Args:
            dest (Path): Destination path where the video and its analysis data have been copied.
        &#34;&#34;&#34;
        super()._updateMetaForCopy(dest)
        self._copyAnalysisData(dest.parent, Path(dest.name))
        
    
    def _updateMetaForMove(self, dest_dir: Path):
        &#34;&#34;&#34;
        Overrides the superclass method to update metadata for a video after moving. Manages relocation of analysis data and updates the video&#39;s metadata to reflect the move.

        Args:
            dest_dir (Path): Destination directory to which the video and its analysis data have been moved.
        &#34;&#34;&#34;
        super()._updateMetaForMove(dest_dir)
        self._copyAnalysisData(dest_dir, Path(self._path.name), move=True)


    def _syncAnalysisState(self, engine=&#34;vpr_engine.anyloc_engine.AnyLocEngine&#34;):
        &#34;&#34;&#34;
        Overrides to synchronize the video&#39;s analysis state with a specified analysis engine. Updates the video&#39;s metadata to reflect current analysis state.

        Args:
            engine (str, optional): Qualified class name of the analysis engine for state checking. Defaults to &#34;vpr_engine.anyloc_engine.AnyLocEngine&#34;.

        Raises:
            ValueError: If the analysis engine cannot be found or initialized.
        &#34;&#34;&#34;
        assert self._type == FileType.FILE
        # from quetzal.engines.vpr_engine.anyloc_engine import AnyLocEngine
        
        module_path, class_name = engine.rsplit(&#34;.&#34;, 1)
        if module_path:
            module = importlib.import_module(f&#34;quetzal.engines.{module_path}&#34;)
            engine_class: AbstractEngine = getattr(module, class_name)
        
        if engine_class is None:
            raise ValueError(&#34;Engine Definition Not Found&#34;)
        
        video = DatabaseVideo(
            path=self._path,
            root_dir=self._root_dir,
            metadata_dir=self._metadata_dir,
            user=self._user,
            home=self._home,
        )
            
        if engine_class.is_video_analyzed(video):
            self._updateMetaForAnalyze(new_progress=AnalysisProgress.FULL)
            self._analysis_progress = AnalysisProgress.FULL
            return

        video = QueryVideo(
            path=self._path,
            root_dir=self._root_dir,
            metadata_dir=self._metadata_dir,
            user=self._user,
            home=self._home,
        )

        if engine_class.is_video_analyzed(video):
            self._updateMetaForAnalyze(new_progress=AnalysisProgress.HALF)
            self._analysis_progress = AnalysisProgress.HALF
            return

        self._updateMetaForAnalyze(new_progress=AnalysisProgress.NONE)
        self._analysis_progress = AnalysisProgress.NONE
        return


    def _analyze(self, option: AnalysisProgress, engine=&#34;vpr_engine.anyloc_engine.AnyLocEngine&#34;, device=torch.device(&#34;cuda:0&#34;)):
        &#34;&#34;&#34;
        Overrides to analyze the video based on a specified level of analysis progress, using an analysis engine and device. Updates the video&#39;s analysis state and metadata upon completion.

        Args:
            option (AnalysisProgress): Desired analysis level.
            engine (str, optional): Qualified class name of the analysis engine. Defaults to &#34;vpr_engine.anyloc_engine.AnyLocEngine&#34;.
            device (torch.device, optional): Computing device for analysis. Defaults to &#34;cuda:0&#34;.

        Returns:
            str: Message indicating analysis completion.
        &#34;&#34;&#34;
        assert (
            self._mode == AccessMode.OWNER or self._permission != Permission.READ_ONLY
        )
        self.debug(f&#34;\n\t{self.name} called on analyze {option}\n&#34;)
        
        if option == None:
            return None

        self.debug(&#34;I am here&#34;)

        self._syncAnalysisState(engine)
        if self._analysis_progress &gt;= option:
            return None
        
        module_path, class_name = engine.rsplit(&#34;.&#34;, 1)
        if module_path:
            module = importlib.import_module(f&#34;quetzal.engines.{module_path}&#34;)
            engine_class: AbstractEngine = getattr(module, class_name)
        
        if engine_class is None:
            raise ValueError(&#34;Engine Definition Not Found&#34;)
        
        self.debug(engine_class)
                
        if option == AnalysisProgress.FULL:
            video = DatabaseVideo(
                path=self._path,
                root_dir=self._root_dir,
                metadata_dir=self._metadata_dir,
                user=self._user,
                home=self._home,
            )
        if option == AnalysisProgress.HALF:
            video = QueryVideo(
                path=self._path,
                root_dir=self._root_dir,
                metadata_dir=self._metadata_dir,
                user=self._user,
                home=self._home,
            )
            
        engine_class(device = device).analyze_video(video)

        self._updateMetaForAnalyze(new_progress=option)
        self._analysis_progress = option
        
        return f&#39;&#34;{self.name}&#34; Analysis Done&#39;

    
class DatabaseVideo(Video):
    &#34;&#34;&#34;
    A subclass of Video for processing database-type videos.

    Inherits all attributes and methods from Video.
    &#34;&#34;&#34;
    
    FPS = 6
    RESOLUTION = 1024

    def __init__(
        self, 
        path: Union[str, Path],
        root_dir: Union[str, Path],
        metadata_dir: Union[str, Path],        
        user: str = None,
        home: Union[str, Path] = &#34;./&#34;, 
        metadata = None,
        parent: &#39;QuetzalFile&#39; = None,
    ):
        &#34;&#34;&#34;
        Initialize the DatabaseVideo object with dataset directory, project, and video name.

        Args:
            datasets_dir (str): The root directory for datasets.
            project_name (str): The name of the specific project.
            video_name (str): The name of the video file.

        Dataset structure
            root_datsets_dir/
            |
            ├── project_name/
            |   ├── raw_video/
            |   |   ├── video_name.mp4
            |   |   └── ...
            |   |
            |   ├── database/
            |   |   ├── video_name/
            |   |   |   ├── frames_{fps}_{resolution}/
            |   |   |   |   ├── frame_%05.jpg
            |   |   |   |   └── ...
            |   |   |   └── ...
            |   |   └── ...
            |   |
            |   ├── query/
            |   |   ├── video_name/
            |   |   |   ├── frames_{fps}_{resolution}/
            |   |   |   |   ├── frame_%05.jpg
            |   |   |   |   └── ...
            |   |   |   └── ...
            |   |   └── ...
            |   └── ...
            └── ...
        &#34;&#34;&#34;

        # Override video_type to be &#34;database&#34;
        super().__init__(
            path=path,
            root_dir=root_dir,
            metadata_dir=metadata_dir,
            user=user,
            metadata=metadata,
            parent=parent,
            video_type=&#34;database&#34;,
            home=home,
            fps=self.FPS,
            resolution=self.RESOLUTION,
        )
    
    @staticmethod
    def from_quetzal_file(file: QuetzalFile):
        &#34;&#34;&#34;
        Creates a DatabaseVideo instance from an existing QuetzalFile object. This method allows for the easy conversion of a general file object into a DatabaseVideo, which is specialized for handling video analysis in a database context.

        Args:
            file (QuetzalFile): The QuetzalFile object to be converted into a DatabaseVideo.

        Returns:
            DatabaseVideo: A new DatabaseVideo object initialized with the properties from the provided QuetzalFile.
        &#34;&#34;&#34;
        database_video = DatabaseVideo(
            path=file._path,
            root_dir=file._root_dir,
            metadata_dir=file._metadata_dir,
            user=file._user,
            home=file._home,
        )
        
        return database_video


class QueryVideo(Video):
    &#34;&#34;&#34;
    A subclass of Video for processing query-type videos.

    Inherits all attributes and methods from Video.
    &#34;&#34;&#34;
    FPS = 2
    RESOLUTION = 1024
    
    def __init__(
        self, 
        path: Union[str, Path],
        root_dir: Union[str, Path],
        metadata_dir: Union[str, Path],        
        user: str = None,
        home: Union[str, Path] = &#34;./&#34;, 
        metadata = None,
        parent = None,
    ):
        &#34;&#34;&#34;
        Initialize the QueryVideo object with dataset directory, project, and video name.

        Args:
            datasets_dir (str): The root directory for datasets.
            project_name (str): The name of the specific project.
            video_name (str): The name of the video file.

        dataset_dir: root datasets dir
        project_name: name of the specific project the drone video is taken
        video_name: video file name

        Dataset structure
            root_datsets_dir/
            |
            ├── project_name/
            |   ├── raw_video/
            |   |   ├── video_name.mp4
            |   |   └── ...
            |   |
            |   ├── database/
            |   |   ├── video_name/
            |   |   |   ├── frames_{fps}_{resolution}/
            |   |   |   |   ├── frame_%05.jpg
            |   |   |   |   └── ...
            |   |   |   └── ...
            |   |   └── ...
            |   |
            |   ├── query/
            |   |   ├── video_name/
            |   |   |   ├── frames_{fps}_{resolution}/
            |   |   |   |   ├── frame_%05.jpg
            |   |   |   |   └── ...
            |   |   |   └── ...
            |   |   └── ...
            |   └── ...
            └── ...
        &#34;&#34;&#34;

        # Override video_type to be &#34;database&#34;
        super().__init__(
            path=path,
            root_dir=root_dir,
            metadata_dir=metadata_dir,
            user=user,
            home=home,
            metadata=metadata,
            parent=parent,
            video_type=&#34;query&#34;,
            fps=self.FPS,
            resolution=self.RESOLUTION,
        )
        
    def _convert_from_database(self, verbose):
        &#34;&#34;&#34;
        Converts frames from an associated DatabaseVideo to fit the requirements of a QueryVideo. This method is particularly useful when high-resolution frames from a database video need to be processed or analyzed at a different resolution or frame rate.

        Args:
            verbose (bool): If True, additional logs regarding the conversion process are displayed.

        Returns:
            bool: True if the conversion is successful, False otherwise.
        &#34;&#34;&#34;
        database_video = DatabaseVideo(
            path=self._path,
            root_dir=self._root_dir,
            metadata_dir=self._metadata_dir,
            user=self._user   
        )
        database_target = database_video.dataset_dir
        if not database_video.is_dir_valid(database_target):
            return False
        
        if verbose:
            self.logger.info(
                f&#34;Extracing Frames in fps={self.fps}, res={self.resolution} from Database...&#34;
            )
            
        target_dir = self.dataset_dir
        os.makedirs(target_dir, exist_ok=True)
        
        database_frames = database_video.get_frames(verbose=False)
        database_frames = [os.path.basename(frame) for frame in database_frames]
        
        every_third_frame = database_frames[::3]
        for i, frame in enumerate(every_third_frame):
            old_path = os.path.join(database_target, frame)
            new_frame_name = f&#34;frame{i+1:05d}.jpg&#34;
            new_path = os.path.join(target_dir, new_frame_name)
            
            # Copying the file
            shutil.copy2(old_path, new_path)
            
        frame_count_file = join(target_dir, &#34;frame_counts.txt&#34;)
        with open(frame_count_file, &#34;w&#34;) as f:
            f.write(str(len(every_third_frame)))
        
        return True

        
    def get_frames(self, verbose: bool = True) -&gt; List[str]:
        &#34;&#34;&#34;
        Overrides the get_frames method from the Video superclass to include a step that checks for the existence of frames at the desired fps and resolution. If they do not exist, it attempts to generate them by converting frames from the associated DatabaseVideo.

        Args:
            verbose (bool, optional): If True, logs additional information about the frame retrieval or generation process. Defaults to True.

        Returns:
            list: A list of frame file paths after ensuring they are available at the desired fps and resolution.
        &#34;&#34;&#34;

        target_dir = self.dataset_dir

        with self._lock:
            if not self.is_dir_valid(target_dir):
                os.makedirs(target_dir, exist_ok=True)           
                self._convert_from_database(verbose)               

            frame_list = super().get_frames()
            
        return frame_list

    @staticmethod
    def from_quetzal_file(file: QuetzalFile):
        &#34;&#34;&#34;
        Creates a QueryVideo instance from an existing QuetzalFile object. This method facilitates the conversion of a generic file object into a QueryVideo, tailored for analyzing query-type videos within the system.

        Args:
            file (QuetzalFile): The QuetzalFile object to be transformed into a QueryVideo.

        Returns:
            QueryVideo: A new QueryVideo object initialized with the attributes from the given QuetzalFile.
        &#34;&#34;&#34;
        query = QueryVideo(
            path=file._path,
            root_dir=file._root_dir,
            metadata_dir=file._metadata_dir,
            user=file._user,
            home=file._home,
        )
        return query
        


# TODO
class LiveQueryVideo(Video):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, video_type=&#34;query&#34;, **kwargs)

    def get_frames(self, fps=2, resolution=1024):
        super().get_frames(fps, resolution)


## LET pdoc3 to generate documentation for private methods 
__pdoc__ = {name: True
            for name, klass in globals().items()
            if name.startswith(&#39;_&#39;) and isinstance(klass, type)}
__pdoc__.update({f&#39;{name}.{member}&#39;: True
                 for name, klass in globals().items()
                 if isinstance(klass, type)
                 for member in klass.__dict__.keys()
                 if member not in {&#39;__module__&#39;, &#39;__dict__&#39;, 
                                   &#39;__weakref__&#39;, &#39;__doc__&#39;}})</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="quetzal.dtos.video.extract_fps_res"><code class="name flex">
<span>def <span class="ident">extract_fps_res</span></span>(<span>directory_name: str) ‑> Union[tuple[quetzal.dtos.video.Fps, quetzal.dtos.video.Resolution], tuple[None, None]]</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts frames per second (fps) and resolution from a directory name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>directory_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The directory name from which to extract the fps and resolution.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A tuple (fps, resolution) if extraction is successful, otherwise (None, None).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_fps_res(directory_name: str) -&gt; Union[tuple[Fps, Resolution], tuple[None, None]]:
    &#34;&#34;&#34;
    Extracts frames per second (fps) and resolution from a directory name.

    Args:
        directory_name (str): The directory name from which to extract the fps and resolution.

    Returns:
        tuple: A tuple (fps, resolution) if extraction is successful, otherwise (None, None).
    &#34;&#34;&#34;

    # Regular expression to match &#39;frames_{fps}_{resolution}&#39;
    pattern = re.compile(r&#34;frames_(\d+)_(\d+)&#34;)
    match = pattern.search(directory_name)
    if match:
        fps = int(match.group(1))
        resolution = int(match.group(2))
        return fps, resolution
    else:
        print(f&#34;Invalid directory name: {directory_name}&#34;)
        return None, None</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.frame_count"><code class="name flex">
<span>def <span class="ident">frame_count</span></span>(<span>fp: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the number of frames from a file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fp</code></strong> :&ensp;<code>str</code></dt>
<dd>File path containing the frame count.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of frames.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frame_count(fp: str) -&gt; str:
    &#34;&#34;&#34;
    Reads the number of frames from a file.

    Args:
        fp (str): File path containing the frame count.

    Returns:
        int: The number of frames.
    &#34;&#34;&#34;
    return int(open(fp, &#34;r&#34;).read().strip())</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="quetzal.dtos.video.DatabaseVideo"><code class="flex name class">
<span>class <span class="ident">DatabaseVideo</span></span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of Video for processing database-type videos.</p>
<p>Inherits all attributes and methods from Video.</p>
<p>Initialize the DatabaseVideo object with dataset directory, project, and video name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>datasets_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>The root directory for datasets.</dd>
<dt><strong><code>project_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the specific project.</dd>
<dt><strong><code>video_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the video file.</dd>
</dl>
<p>Dataset structure
root_datsets_dir/
|
├── project_name/
|
├── raw_video/
|
|
├── video_name.mp4
|
|
└── &hellip;
|
|
|
├── database/
|
|
├── video_name/
|
|
|
├── frames_{fps}<em>{resolution}/
|
|
|
|
├── frame</em>%05.jpg
|
|
|
|
└── &hellip;
|
|
|
└── &hellip;
|
|
└── &hellip;
|
|
|
├── query/
|
|
├── video_name/
|
|
|
├── frames_{fps}<em>{resolution}/
|
|
|
|
├── frame</em>%05.jpg
|
|
|
|
└── &hellip;
|
|
|
└── &hellip;
|
|
└── &hellip;
|
└── &hellip;
└── &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DatabaseVideo(Video):
    &#34;&#34;&#34;
    A subclass of Video for processing database-type videos.

    Inherits all attributes and methods from Video.
    &#34;&#34;&#34;
    
    FPS = 6
    RESOLUTION = 1024

    def __init__(
        self, 
        path: Union[str, Path],
        root_dir: Union[str, Path],
        metadata_dir: Union[str, Path],        
        user: str = None,
        home: Union[str, Path] = &#34;./&#34;, 
        metadata = None,
        parent: &#39;QuetzalFile&#39; = None,
    ):
        &#34;&#34;&#34;
        Initialize the DatabaseVideo object with dataset directory, project, and video name.

        Args:
            datasets_dir (str): The root directory for datasets.
            project_name (str): The name of the specific project.
            video_name (str): The name of the video file.

        Dataset structure
            root_datsets_dir/
            |
            ├── project_name/
            |   ├── raw_video/
            |   |   ├── video_name.mp4
            |   |   └── ...
            |   |
            |   ├── database/
            |   |   ├── video_name/
            |   |   |   ├── frames_{fps}_{resolution}/
            |   |   |   |   ├── frame_%05.jpg
            |   |   |   |   └── ...
            |   |   |   └── ...
            |   |   └── ...
            |   |
            |   ├── query/
            |   |   ├── video_name/
            |   |   |   ├── frames_{fps}_{resolution}/
            |   |   |   |   ├── frame_%05.jpg
            |   |   |   |   └── ...
            |   |   |   └── ...
            |   |   └── ...
            |   └── ...
            └── ...
        &#34;&#34;&#34;

        # Override video_type to be &#34;database&#34;
        super().__init__(
            path=path,
            root_dir=root_dir,
            metadata_dir=metadata_dir,
            user=user,
            metadata=metadata,
            parent=parent,
            video_type=&#34;database&#34;,
            home=home,
            fps=self.FPS,
            resolution=self.RESOLUTION,
        )
    
    @staticmethod
    def from_quetzal_file(file: QuetzalFile):
        &#34;&#34;&#34;
        Creates a DatabaseVideo instance from an existing QuetzalFile object. This method allows for the easy conversion of a general file object into a DatabaseVideo, which is specialized for handling video analysis in a database context.

        Args:
            file (QuetzalFile): The QuetzalFile object to be converted into a DatabaseVideo.

        Returns:
            DatabaseVideo: A new DatabaseVideo object initialized with the properties from the provided QuetzalFile.
        &#34;&#34;&#34;
        database_video = DatabaseVideo(
            path=file._path,
            root_dir=file._root_dir,
            metadata_dir=file._metadata_dir,
            user=file._user,
            home=file._home,
        )
        
        return database_video</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="quetzal.dtos.video.Video" href="#quetzal.dtos.video.Video">Video</a></li>
<li><a title="quetzal.dtos.dtos.QuetzalFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="quetzal.dtos.video.DatabaseVideo.FPS"><code class="name">var <span class="ident">FPS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.video.DatabaseVideo.RESOLUTION"><code class="name">var <span class="ident">RESOLUTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="quetzal.dtos.video.DatabaseVideo.from_quetzal_file"><code class="name flex">
<span>def <span class="ident">from_quetzal_file</span></span>(<span>file: <a title="quetzal.dtos.dtos.QuetzalFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a DatabaseVideo instance from an existing QuetzalFile object. This method allows for the easy conversion of a general file object into a DatabaseVideo, which is specialized for handling video analysis in a database context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code>QuetzalFile</code></dt>
<dd>The QuetzalFile object to be converted into a DatabaseVideo.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="quetzal.dtos.video.DatabaseVideo" href="#quetzal.dtos.video.DatabaseVideo">DatabaseVideo</a></code></dt>
<dd>A new DatabaseVideo object initialized with the properties from the provided QuetzalFile.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_quetzal_file(file: QuetzalFile):
    &#34;&#34;&#34;
    Creates a DatabaseVideo instance from an existing QuetzalFile object. This method allows for the easy conversion of a general file object into a DatabaseVideo, which is specialized for handling video analysis in a database context.

    Args:
        file (QuetzalFile): The QuetzalFile object to be converted into a DatabaseVideo.

    Returns:
        DatabaseVideo: A new DatabaseVideo object initialized with the properties from the provided QuetzalFile.
    &#34;&#34;&#34;
    database_video = DatabaseVideo(
        path=file._path,
        root_dir=file._root_dir,
        metadata_dir=file._metadata_dir,
        user=file._user,
        home=file._home,
    )
    
    return database_video</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="quetzal.dtos.video.DatabaseVideo.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, path: Union[str, pathlib.Path], root_dir: Union[str, pathlib.Path], metadata_dir: Union[str, pathlib.Path], user: str = None, home: Union[str, pathlib.Path] = './', metadata=None, parent: QuetzalFile = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the DatabaseVideo object with dataset directory, project, and video name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>datasets_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>The root directory for datasets.</dd>
<dt><strong><code>project_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the specific project.</dd>
<dt><strong><code>video_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the video file.</dd>
</dl>
<p>Dataset structure
root_datsets_dir/
|
├── project_name/
|
├── raw_video/
|
|
├── video_name.mp4
|
|
└── &hellip;
|
|
|
├── database/
|
|
├── video_name/
|
|
|
├── frames_{fps}<em>{resolution}/
|
|
|
|
├── frame</em>%05.jpg
|
|
|
|
└── &hellip;
|
|
|
└── &hellip;
|
|
└── &hellip;
|
|
|
├── query/
|
|
├── video_name/
|
|
|
├── frames_{fps}<em>{resolution}/
|
|
|
|
├── frame</em>%05.jpg
|
|
|
|
└── &hellip;
|
|
|
└── &hellip;
|
|
└── &hellip;
|
└── &hellip;
└── &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __init__(
    self, 
    path: Union[str, Path],
    root_dir: Union[str, Path],
    metadata_dir: Union[str, Path],        
    user: str = None,
    home: Union[str, Path] = &#34;./&#34;, 
    metadata = None,
    parent: &#39;QuetzalFile&#39; = None,
):
    &#34;&#34;&#34;
    Initialize the DatabaseVideo object with dataset directory, project, and video name.

    Args:
        datasets_dir (str): The root directory for datasets.
        project_name (str): The name of the specific project.
        video_name (str): The name of the video file.

    Dataset structure
        root_datsets_dir/
        |
        ├── project_name/
        |   ├── raw_video/
        |   |   ├── video_name.mp4
        |   |   └── ...
        |   |
        |   ├── database/
        |   |   ├── video_name/
        |   |   |   ├── frames_{fps}_{resolution}/
        |   |   |   |   ├── frame_%05.jpg
        |   |   |   |   └── ...
        |   |   |   └── ...
        |   |   └── ...
        |   |
        |   ├── query/
        |   |   ├── video_name/
        |   |   |   ├── frames_{fps}_{resolution}/
        |   |   |   |   ├── frame_%05.jpg
        |   |   |   |   └── ...
        |   |   |   └── ...
        |   |   └── ...
        |   └── ...
        └── ...
    &#34;&#34;&#34;

    # Override video_type to be &#34;database&#34;
    super().__init__(
        path=path,
        root_dir=root_dir,
        metadata_dir=metadata_dir,
        user=user,
        metadata=metadata,
        parent=parent,
        video_type=&#34;database&#34;,
        home=home,
        fps=self.FPS,
        resolution=self.RESOLUTION,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="quetzal.dtos.video.Video" href="#quetzal.dtos.video.Video">Video</a></b></code>:
<ul class="hlist">
<li><code><a title="quetzal.dtos.video.Video.__eq__" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.__eq__">__eq__</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.__format__" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.__format__">__format__</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.__hash__" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.__hash__">__hash__</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.__repr__" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.__repr__">__repr__</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._abs_path" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._abs_path">_abs_path</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._analyze" href="#quetzal.dtos.video.Video._analyze">_analyze</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._copy" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._copy">_copy</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._copyAnalysisData" href="#quetzal.dtos.video.Video._copyAnalysisData">_copyAnalysisData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._dataset_dir" href="#quetzal.dtos.video.Video._dataset_dir">_dataset_dir</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._delete" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._delete">_delete</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._deleteAnalysisData" href="#quetzal.dtos.video.Video._deleteAnalysisData">_deleteAnalysisData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._editDescription" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._editDescription">_editDescription</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._getDescriptionPath" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._getDescriptionPath">_getDescriptionPath</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._getMetaDataPath" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._getMetaDataPath">_getMetaDataPath</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._instantiateFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._instantiateFile">_instantiateFile</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._loadMetaData" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._loadMetaData">_loadMetaData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._makeDefaultDescription" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._makeDefaultDescription">_makeDefaultDescription</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._move" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._move">_move</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._newDirectory" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._newDirectory">_newDirectory</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._parseMetadata" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._parseMetadata">_parseMetadata</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._rename" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._rename">_rename</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._renameAnalysisData" href="#quetzal.dtos.video.Video._renameAnalysisData">_renameAnalysisData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._share" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._share">_share</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._syncAnalysisState" href="#quetzal.dtos.video.Video._syncAnalysisState">_syncAnalysisState</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForAnalyze" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._updateMetaForAnalyze">_updateMetaForAnalyze</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForCopy" href="#quetzal.dtos.video.Video._updateMetaForCopy">_updateMetaForCopy</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForDelete" href="#quetzal.dtos.video.Video._updateMetaForDelete">_updateMetaForDelete</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForMove" href="#quetzal.dtos.video.Video._updateMetaForMove">_updateMetaForMove</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForNewFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._updateMetaForNewFile">_updateMetaForNewFile</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForRename" href="#quetzal.dtos.video.Video._updateMetaForRename">_updateMetaForRename</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForShare" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._updateMetaForShare">_updateMetaForShare</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._upload" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._upload">_upload</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.analysis_progress" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.analysis_progress">analysis_progress</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.avaliable_frames" href="#quetzal.dtos.video.Video.avaliable_frames">avaliable_frames</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.createdBy" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.createdBy">createdBy</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.dataset_dir" href="#quetzal.dtos.video.Video.dataset_dir">dataset_dir</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.fps" href="#quetzal.dtos.video.Video.fps">fps</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.frame_len" href="#quetzal.dtos.video.Video.frame_len">frame_len</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.fromFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.fromFile">fromFile</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.full_path" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.full_path">full_path</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.getDescription" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.getDescription">getDescription</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.getDescriptionPath" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.getDescriptionPath">getDescriptionPath</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.getMetaDataPath" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.getMetaDataPath">getMetaDataPath</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frame_idx" href="#quetzal.dtos.video.Video.get_frame_idx">get_frame_idx</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frame_idx_at_time" href="#quetzal.dtos.video.Video.get_frame_idx_at_time">get_frame_idx_at_time</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frame_list" href="#quetzal.dtos.video.Video.get_frame_list">get_frame_list</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frame_time" href="#quetzal.dtos.video.Video.get_frame_time">get_frame_time</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frames" href="#quetzal.dtos.video.Video.get_frames">get_frames</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_raw_frame_at" href="#quetzal.dtos.video.Video.get_raw_frame_at">get_raw_frame_at</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_video_end_idx" href="#quetzal.dtos.video.Video.get_video_end_idx">get_video_end_idx</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_video_start_idx" href="#quetzal.dtos.video.Video.get_video_start_idx">get_video_start_idx</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.home" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.home">home</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.is_dir_valid" href="#quetzal.dtos.video.Video.is_dir_valid">is_dir_valid</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.iterdir" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.iterdir">iterdir</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.loadMetaData" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.loadMetaData">loadMetaData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.load_video_info" href="#quetzal.dtos.video.Video.load_video_info">load_video_info</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.mode" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.mode">mode</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.name" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.name">name</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.path" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.path">path</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.perform" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.perform">perform</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.permission" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.permission">permission</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.resolution" href="#quetzal.dtos.video.Video.resolution">resolution</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.set_video_end" href="#quetzal.dtos.video.Video.set_video_end">set_video_end</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.set_video_start" href="#quetzal.dtos.video.Video.set_video_start">set_video_start</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.type" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.type">type</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.user" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.user">user</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.video_type" href="#quetzal.dtos.video.Video.video_type">video_type</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.visibility" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.visibility">visibility</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="quetzal.dtos.video.LiveQueryVideo"><code class="flex name class">
<span>class <span class="ident">LiveQueryVideo</span></span>
</code></dt>
<dd>
<div class="desc"><p>Represents a video file within the Quetzal system, capable of processing drone footage.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt>video_type (Literal["database", "query"]): Specifies the type of the video, indicating</dt>
<dt>its role within the dataset as either a reference (database) or subject (query) video.</dt>
<dt><strong><code>fps</code></strong> :&ensp;<code>Fps</code></dt>
<dd>Frames per second at which the video is processed.</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>Resolution</code></dt>
<dd>Resolution at which the video frames are processed.</dd>
</dl>
<p>Initializes a Video object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>The path to the video file, relative to <code>root_dir</code>.</dd>
<dt><strong><code>root_dir</code></strong></dt>
<dd>The root directory for datasets.</dd>
<dt><strong><code>metadata_dir</code></strong></dt>
<dd>The root directory for metadata.</dd>
<dt><strong><code>user</code></strong></dt>
<dd>The user associated with the video file. Defaults to a guest user.</dd>
<dt><strong><code>home</code></strong></dt>
<dd>The base home directory path. Defaults to "./".</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Metadata associated with the video file.</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>The parent QuetzalFile object, if applicable.</dd>
<dt><strong><code>video_type</code></strong></dt>
<dd>The type of the video, either 'database' or 'query'. Defaults to 'query'.</dd>
<dt><strong><code>fps</code></strong></dt>
<dd>The frames per second at which the video is processed. Defaults to 2.</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>The resolution at which the video frames are processed. Defaults to 1024.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LiveQueryVideo(Video):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, video_type=&#34;query&#34;, **kwargs)

    def get_frames(self, fps=2, resolution=1024):
        super().get_frames(fps, resolution)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="quetzal.dtos.video.Video" href="#quetzal.dtos.video.Video">Video</a></li>
<li><a title="quetzal.dtos.dtos.QuetzalFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="quetzal.dtos.video.Video" href="#quetzal.dtos.video.Video">Video</a></b></code>:
<ul class="hlist">
<li><code><a title="quetzal.dtos.video.Video.__eq__" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.__eq__">__eq__</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.__format__" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.__format__">__format__</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.__hash__" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.__hash__">__hash__</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.__init__" href="#quetzal.dtos.video.Video.__init__">__init__</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.__repr__" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.__repr__">__repr__</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._abs_path" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._abs_path">_abs_path</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._analyze" href="#quetzal.dtos.video.Video._analyze">_analyze</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._copy" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._copy">_copy</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._copyAnalysisData" href="#quetzal.dtos.video.Video._copyAnalysisData">_copyAnalysisData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._dataset_dir" href="#quetzal.dtos.video.Video._dataset_dir">_dataset_dir</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._delete" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._delete">_delete</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._deleteAnalysisData" href="#quetzal.dtos.video.Video._deleteAnalysisData">_deleteAnalysisData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._editDescription" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._editDescription">_editDescription</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._getDescriptionPath" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._getDescriptionPath">_getDescriptionPath</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._getMetaDataPath" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._getMetaDataPath">_getMetaDataPath</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._instantiateFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._instantiateFile">_instantiateFile</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._loadMetaData" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._loadMetaData">_loadMetaData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._makeDefaultDescription" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._makeDefaultDescription">_makeDefaultDescription</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._move" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._move">_move</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._newDirectory" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._newDirectory">_newDirectory</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._parseMetadata" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._parseMetadata">_parseMetadata</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._rename" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._rename">_rename</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._renameAnalysisData" href="#quetzal.dtos.video.Video._renameAnalysisData">_renameAnalysisData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._share" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._share">_share</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._syncAnalysisState" href="#quetzal.dtos.video.Video._syncAnalysisState">_syncAnalysisState</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForAnalyze" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._updateMetaForAnalyze">_updateMetaForAnalyze</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForCopy" href="#quetzal.dtos.video.Video._updateMetaForCopy">_updateMetaForCopy</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForDelete" href="#quetzal.dtos.video.Video._updateMetaForDelete">_updateMetaForDelete</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForMove" href="#quetzal.dtos.video.Video._updateMetaForMove">_updateMetaForMove</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForNewFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._updateMetaForNewFile">_updateMetaForNewFile</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForRename" href="#quetzal.dtos.video.Video._updateMetaForRename">_updateMetaForRename</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForShare" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._updateMetaForShare">_updateMetaForShare</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._upload" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._upload">_upload</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.analysis_progress" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.analysis_progress">analysis_progress</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.avaliable_frames" href="#quetzal.dtos.video.Video.avaliable_frames">avaliable_frames</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.createdBy" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.createdBy">createdBy</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.dataset_dir" href="#quetzal.dtos.video.Video.dataset_dir">dataset_dir</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.fps" href="#quetzal.dtos.video.Video.fps">fps</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.frame_len" href="#quetzal.dtos.video.Video.frame_len">frame_len</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.fromFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.fromFile">fromFile</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.full_path" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.full_path">full_path</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.getDescription" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.getDescription">getDescription</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.getDescriptionPath" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.getDescriptionPath">getDescriptionPath</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.getMetaDataPath" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.getMetaDataPath">getMetaDataPath</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frame_idx" href="#quetzal.dtos.video.Video.get_frame_idx">get_frame_idx</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frame_idx_at_time" href="#quetzal.dtos.video.Video.get_frame_idx_at_time">get_frame_idx_at_time</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frame_list" href="#quetzal.dtos.video.Video.get_frame_list">get_frame_list</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frame_time" href="#quetzal.dtos.video.Video.get_frame_time">get_frame_time</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frames" href="#quetzal.dtos.video.Video.get_frames">get_frames</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_raw_frame_at" href="#quetzal.dtos.video.Video.get_raw_frame_at">get_raw_frame_at</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_video_end_idx" href="#quetzal.dtos.video.Video.get_video_end_idx">get_video_end_idx</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_video_start_idx" href="#quetzal.dtos.video.Video.get_video_start_idx">get_video_start_idx</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.home" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.home">home</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.is_dir_valid" href="#quetzal.dtos.video.Video.is_dir_valid">is_dir_valid</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.iterdir" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.iterdir">iterdir</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.loadMetaData" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.loadMetaData">loadMetaData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.load_video_info" href="#quetzal.dtos.video.Video.load_video_info">load_video_info</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.mode" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.mode">mode</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.name" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.name">name</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.path" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.path">path</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.perform" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.perform">perform</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.permission" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.permission">permission</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.resolution" href="#quetzal.dtos.video.Video.resolution">resolution</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.set_video_end" href="#quetzal.dtos.video.Video.set_video_end">set_video_end</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.set_video_start" href="#quetzal.dtos.video.Video.set_video_start">set_video_start</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.type" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.type">type</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.user" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.user">user</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.video_type" href="#quetzal.dtos.video.Video.video_type">video_type</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.visibility" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.visibility">visibility</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="quetzal.dtos.video.QueryVideo"><code class="flex name class">
<span>class <span class="ident">QueryVideo</span></span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of Video for processing query-type videos.</p>
<p>Inherits all attributes and methods from Video.</p>
<p>Initialize the QueryVideo object with dataset directory, project, and video name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>datasets_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>The root directory for datasets.</dd>
<dt><strong><code>project_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the specific project.</dd>
<dt><strong><code>video_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the video file.</dd>
</dl>
<p>dataset_dir: root datasets dir
project_name: name of the specific project the drone video is taken
video_name: video file name</p>
<p>Dataset structure
root_datsets_dir/
|
├── project_name/
|
├── raw_video/
|
|
├── video_name.mp4
|
|
└── &hellip;
|
|
|
├── database/
|
|
├── video_name/
|
|
|
├── frames_{fps}<em>{resolution}/
|
|
|
|
├── frame</em>%05.jpg
|
|
|
|
└── &hellip;
|
|
|
└── &hellip;
|
|
└── &hellip;
|
|
|
├── query/
|
|
├── video_name/
|
|
|
├── frames_{fps}<em>{resolution}/
|
|
|
|
├── frame</em>%05.jpg
|
|
|
|
└── &hellip;
|
|
|
└── &hellip;
|
|
└── &hellip;
|
└── &hellip;
└── &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QueryVideo(Video):
    &#34;&#34;&#34;
    A subclass of Video for processing query-type videos.

    Inherits all attributes and methods from Video.
    &#34;&#34;&#34;
    FPS = 2
    RESOLUTION = 1024
    
    def __init__(
        self, 
        path: Union[str, Path],
        root_dir: Union[str, Path],
        metadata_dir: Union[str, Path],        
        user: str = None,
        home: Union[str, Path] = &#34;./&#34;, 
        metadata = None,
        parent = None,
    ):
        &#34;&#34;&#34;
        Initialize the QueryVideo object with dataset directory, project, and video name.

        Args:
            datasets_dir (str): The root directory for datasets.
            project_name (str): The name of the specific project.
            video_name (str): The name of the video file.

        dataset_dir: root datasets dir
        project_name: name of the specific project the drone video is taken
        video_name: video file name

        Dataset structure
            root_datsets_dir/
            |
            ├── project_name/
            |   ├── raw_video/
            |   |   ├── video_name.mp4
            |   |   └── ...
            |   |
            |   ├── database/
            |   |   ├── video_name/
            |   |   |   ├── frames_{fps}_{resolution}/
            |   |   |   |   ├── frame_%05.jpg
            |   |   |   |   └── ...
            |   |   |   └── ...
            |   |   └── ...
            |   |
            |   ├── query/
            |   |   ├── video_name/
            |   |   |   ├── frames_{fps}_{resolution}/
            |   |   |   |   ├── frame_%05.jpg
            |   |   |   |   └── ...
            |   |   |   └── ...
            |   |   └── ...
            |   └── ...
            └── ...
        &#34;&#34;&#34;

        # Override video_type to be &#34;database&#34;
        super().__init__(
            path=path,
            root_dir=root_dir,
            metadata_dir=metadata_dir,
            user=user,
            home=home,
            metadata=metadata,
            parent=parent,
            video_type=&#34;query&#34;,
            fps=self.FPS,
            resolution=self.RESOLUTION,
        )
        
    def _convert_from_database(self, verbose):
        &#34;&#34;&#34;
        Converts frames from an associated DatabaseVideo to fit the requirements of a QueryVideo. This method is particularly useful when high-resolution frames from a database video need to be processed or analyzed at a different resolution or frame rate.

        Args:
            verbose (bool): If True, additional logs regarding the conversion process are displayed.

        Returns:
            bool: True if the conversion is successful, False otherwise.
        &#34;&#34;&#34;
        database_video = DatabaseVideo(
            path=self._path,
            root_dir=self._root_dir,
            metadata_dir=self._metadata_dir,
            user=self._user   
        )
        database_target = database_video.dataset_dir
        if not database_video.is_dir_valid(database_target):
            return False
        
        if verbose:
            self.logger.info(
                f&#34;Extracing Frames in fps={self.fps}, res={self.resolution} from Database...&#34;
            )
            
        target_dir = self.dataset_dir
        os.makedirs(target_dir, exist_ok=True)
        
        database_frames = database_video.get_frames(verbose=False)
        database_frames = [os.path.basename(frame) for frame in database_frames]
        
        every_third_frame = database_frames[::3]
        for i, frame in enumerate(every_third_frame):
            old_path = os.path.join(database_target, frame)
            new_frame_name = f&#34;frame{i+1:05d}.jpg&#34;
            new_path = os.path.join(target_dir, new_frame_name)
            
            # Copying the file
            shutil.copy2(old_path, new_path)
            
        frame_count_file = join(target_dir, &#34;frame_counts.txt&#34;)
        with open(frame_count_file, &#34;w&#34;) as f:
            f.write(str(len(every_third_frame)))
        
        return True

        
    def get_frames(self, verbose: bool = True) -&gt; List[str]:
        &#34;&#34;&#34;
        Overrides the get_frames method from the Video superclass to include a step that checks for the existence of frames at the desired fps and resolution. If they do not exist, it attempts to generate them by converting frames from the associated DatabaseVideo.

        Args:
            verbose (bool, optional): If True, logs additional information about the frame retrieval or generation process. Defaults to True.

        Returns:
            list: A list of frame file paths after ensuring they are available at the desired fps and resolution.
        &#34;&#34;&#34;

        target_dir = self.dataset_dir

        with self._lock:
            if not self.is_dir_valid(target_dir):
                os.makedirs(target_dir, exist_ok=True)           
                self._convert_from_database(verbose)               

            frame_list = super().get_frames()
            
        return frame_list

    @staticmethod
    def from_quetzal_file(file: QuetzalFile):
        &#34;&#34;&#34;
        Creates a QueryVideo instance from an existing QuetzalFile object. This method facilitates the conversion of a generic file object into a QueryVideo, tailored for analyzing query-type videos within the system.

        Args:
            file (QuetzalFile): The QuetzalFile object to be transformed into a QueryVideo.

        Returns:
            QueryVideo: A new QueryVideo object initialized with the attributes from the given QuetzalFile.
        &#34;&#34;&#34;
        query = QueryVideo(
            path=file._path,
            root_dir=file._root_dir,
            metadata_dir=file._metadata_dir,
            user=file._user,
            home=file._home,
        )
        return query</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="quetzal.dtos.video.Video" href="#quetzal.dtos.video.Video">Video</a></li>
<li><a title="quetzal.dtos.dtos.QuetzalFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="quetzal.dtos.video.QueryVideo.FPS"><code class="name">var <span class="ident">FPS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.video.QueryVideo.RESOLUTION"><code class="name">var <span class="ident">RESOLUTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="quetzal.dtos.video.QueryVideo.from_quetzal_file"><code class="name flex">
<span>def <span class="ident">from_quetzal_file</span></span>(<span>file: <a title="quetzal.dtos.dtos.QuetzalFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a QueryVideo instance from an existing QuetzalFile object. This method facilitates the conversion of a generic file object into a QueryVideo, tailored for analyzing query-type videos within the system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code>QuetzalFile</code></dt>
<dd>The QuetzalFile object to be transformed into a QueryVideo.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="quetzal.dtos.video.QueryVideo" href="#quetzal.dtos.video.QueryVideo">QueryVideo</a></code></dt>
<dd>A new QueryVideo object initialized with the attributes from the given QuetzalFile.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_quetzal_file(file: QuetzalFile):
    &#34;&#34;&#34;
    Creates a QueryVideo instance from an existing QuetzalFile object. This method facilitates the conversion of a generic file object into a QueryVideo, tailored for analyzing query-type videos within the system.

    Args:
        file (QuetzalFile): The QuetzalFile object to be transformed into a QueryVideo.

    Returns:
        QueryVideo: A new QueryVideo object initialized with the attributes from the given QuetzalFile.
    &#34;&#34;&#34;
    query = QueryVideo(
        path=file._path,
        root_dir=file._root_dir,
        metadata_dir=file._metadata_dir,
        user=file._user,
        home=file._home,
    )
    return query</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="quetzal.dtos.video.QueryVideo.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, path: Union[str, pathlib.Path], root_dir: Union[str, pathlib.Path], metadata_dir: Union[str, pathlib.Path], user: str = None, home: Union[str, pathlib.Path] = './', metadata=None, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the QueryVideo object with dataset directory, project, and video name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>datasets_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>The root directory for datasets.</dd>
<dt><strong><code>project_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the specific project.</dd>
<dt><strong><code>video_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the video file.</dd>
</dl>
<p>dataset_dir: root datasets dir
project_name: name of the specific project the drone video is taken
video_name: video file name</p>
<p>Dataset structure
root_datsets_dir/
|
├── project_name/
|
├── raw_video/
|
|
├── video_name.mp4
|
|
└── &hellip;
|
|
|
├── database/
|
|
├── video_name/
|
|
|
├── frames_{fps}<em>{resolution}/
|
|
|
|
├── frame</em>%05.jpg
|
|
|
|
└── &hellip;
|
|
|
└── &hellip;
|
|
└── &hellip;
|
|
|
├── query/
|
|
├── video_name/
|
|
|
├── frames_{fps}<em>{resolution}/
|
|
|
|
├── frame</em>%05.jpg
|
|
|
|
└── &hellip;
|
|
|
└── &hellip;
|
|
└── &hellip;
|
└── &hellip;
└── &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __init__(
    self, 
    path: Union[str, Path],
    root_dir: Union[str, Path],
    metadata_dir: Union[str, Path],        
    user: str = None,
    home: Union[str, Path] = &#34;./&#34;, 
    metadata = None,
    parent = None,
):
    &#34;&#34;&#34;
    Initialize the QueryVideo object with dataset directory, project, and video name.

    Args:
        datasets_dir (str): The root directory for datasets.
        project_name (str): The name of the specific project.
        video_name (str): The name of the video file.

    dataset_dir: root datasets dir
    project_name: name of the specific project the drone video is taken
    video_name: video file name

    Dataset structure
        root_datsets_dir/
        |
        ├── project_name/
        |   ├── raw_video/
        |   |   ├── video_name.mp4
        |   |   └── ...
        |   |
        |   ├── database/
        |   |   ├── video_name/
        |   |   |   ├── frames_{fps}_{resolution}/
        |   |   |   |   ├── frame_%05.jpg
        |   |   |   |   └── ...
        |   |   |   └── ...
        |   |   └── ...
        |   |
        |   ├── query/
        |   |   ├── video_name/
        |   |   |   ├── frames_{fps}_{resolution}/
        |   |   |   |   ├── frame_%05.jpg
        |   |   |   |   └── ...
        |   |   |   └── ...
        |   |   └── ...
        |   └── ...
        └── ...
    &#34;&#34;&#34;

    # Override video_type to be &#34;database&#34;
    super().__init__(
        path=path,
        root_dir=root_dir,
        metadata_dir=metadata_dir,
        user=user,
        home=home,
        metadata=metadata,
        parent=parent,
        video_type=&#34;query&#34;,
        fps=self.FPS,
        resolution=self.RESOLUTION,
    )</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.QueryVideo._convert_from_database"><code class="name flex">
<span>def <span class="ident">_convert_from_database</span></span>(<span>self, verbose)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts frames from an associated DatabaseVideo to fit the requirements of a QueryVideo. This method is particularly useful when high-resolution frames from a database video need to be processed or analyzed at a different resolution or frame rate.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, additional logs regarding the conversion process are displayed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the conversion is successful, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _convert_from_database(self, verbose):
    &#34;&#34;&#34;
    Converts frames from an associated DatabaseVideo to fit the requirements of a QueryVideo. This method is particularly useful when high-resolution frames from a database video need to be processed or analyzed at a different resolution or frame rate.

    Args:
        verbose (bool): If True, additional logs regarding the conversion process are displayed.

    Returns:
        bool: True if the conversion is successful, False otherwise.
    &#34;&#34;&#34;
    database_video = DatabaseVideo(
        path=self._path,
        root_dir=self._root_dir,
        metadata_dir=self._metadata_dir,
        user=self._user   
    )
    database_target = database_video.dataset_dir
    if not database_video.is_dir_valid(database_target):
        return False
    
    if verbose:
        self.logger.info(
            f&#34;Extracing Frames in fps={self.fps}, res={self.resolution} from Database...&#34;
        )
        
    target_dir = self.dataset_dir
    os.makedirs(target_dir, exist_ok=True)
    
    database_frames = database_video.get_frames(verbose=False)
    database_frames = [os.path.basename(frame) for frame in database_frames]
    
    every_third_frame = database_frames[::3]
    for i, frame in enumerate(every_third_frame):
        old_path = os.path.join(database_target, frame)
        new_frame_name = f&#34;frame{i+1:05d}.jpg&#34;
        new_path = os.path.join(target_dir, new_frame_name)
        
        # Copying the file
        shutil.copy2(old_path, new_path)
        
    frame_count_file = join(target_dir, &#34;frame_counts.txt&#34;)
    with open(frame_count_file, &#34;w&#34;) as f:
        f.write(str(len(every_third_frame)))
    
    return True</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.QueryVideo.get_frames"><code class="name flex">
<span>def <span class="ident">get_frames</span></span>(<span>self, verbose: bool = True) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Overrides the get_frames method from the Video superclass to include a step that checks for the existence of frames at the desired fps and resolution. If they do not exist, it attempts to generate them by converting frames from the associated DatabaseVideo.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, logs additional information about the frame retrieval or generation process. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of frame file paths after ensuring they are available at the desired fps and resolution.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frames(self, verbose: bool = True) -&gt; List[str]:
    &#34;&#34;&#34;
    Overrides the get_frames method from the Video superclass to include a step that checks for the existence of frames at the desired fps and resolution. If they do not exist, it attempts to generate them by converting frames from the associated DatabaseVideo.

    Args:
        verbose (bool, optional): If True, logs additional information about the frame retrieval or generation process. Defaults to True.

    Returns:
        list: A list of frame file paths after ensuring they are available at the desired fps and resolution.
    &#34;&#34;&#34;

    target_dir = self.dataset_dir

    with self._lock:
        if not self.is_dir_valid(target_dir):
            os.makedirs(target_dir, exist_ok=True)           
            self._convert_from_database(verbose)               

        frame_list = super().get_frames()
        
    return frame_list</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="quetzal.dtos.video.Video" href="#quetzal.dtos.video.Video">Video</a></b></code>:
<ul class="hlist">
<li><code><a title="quetzal.dtos.video.Video.__eq__" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.__eq__">__eq__</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.__format__" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.__format__">__format__</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.__hash__" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.__hash__">__hash__</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.__repr__" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.__repr__">__repr__</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._abs_path" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._abs_path">_abs_path</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._analyze" href="#quetzal.dtos.video.Video._analyze">_analyze</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._copy" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._copy">_copy</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._copyAnalysisData" href="#quetzal.dtos.video.Video._copyAnalysisData">_copyAnalysisData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._dataset_dir" href="#quetzal.dtos.video.Video._dataset_dir">_dataset_dir</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._delete" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._delete">_delete</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._deleteAnalysisData" href="#quetzal.dtos.video.Video._deleteAnalysisData">_deleteAnalysisData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._editDescription" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._editDescription">_editDescription</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._getDescriptionPath" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._getDescriptionPath">_getDescriptionPath</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._getMetaDataPath" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._getMetaDataPath">_getMetaDataPath</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._instantiateFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._instantiateFile">_instantiateFile</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._loadMetaData" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._loadMetaData">_loadMetaData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._makeDefaultDescription" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._makeDefaultDescription">_makeDefaultDescription</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._move" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._move">_move</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._newDirectory" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._newDirectory">_newDirectory</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._parseMetadata" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._parseMetadata">_parseMetadata</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._rename" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._rename">_rename</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._renameAnalysisData" href="#quetzal.dtos.video.Video._renameAnalysisData">_renameAnalysisData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._share" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._share">_share</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._syncAnalysisState" href="#quetzal.dtos.video.Video._syncAnalysisState">_syncAnalysisState</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForAnalyze" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._updateMetaForAnalyze">_updateMetaForAnalyze</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForCopy" href="#quetzal.dtos.video.Video._updateMetaForCopy">_updateMetaForCopy</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForDelete" href="#quetzal.dtos.video.Video._updateMetaForDelete">_updateMetaForDelete</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForMove" href="#quetzal.dtos.video.Video._updateMetaForMove">_updateMetaForMove</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForNewFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._updateMetaForNewFile">_updateMetaForNewFile</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForRename" href="#quetzal.dtos.video.Video._updateMetaForRename">_updateMetaForRename</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForShare" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._updateMetaForShare">_updateMetaForShare</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._upload" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._upload">_upload</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.analysis_progress" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.analysis_progress">analysis_progress</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.avaliable_frames" href="#quetzal.dtos.video.Video.avaliable_frames">avaliable_frames</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.createdBy" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.createdBy">createdBy</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.dataset_dir" href="#quetzal.dtos.video.Video.dataset_dir">dataset_dir</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.fps" href="#quetzal.dtos.video.Video.fps">fps</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.frame_len" href="#quetzal.dtos.video.Video.frame_len">frame_len</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.fromFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.fromFile">fromFile</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.full_path" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.full_path">full_path</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.getDescription" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.getDescription">getDescription</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.getDescriptionPath" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.getDescriptionPath">getDescriptionPath</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.getMetaDataPath" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.getMetaDataPath">getMetaDataPath</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frame_idx" href="#quetzal.dtos.video.Video.get_frame_idx">get_frame_idx</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frame_idx_at_time" href="#quetzal.dtos.video.Video.get_frame_idx_at_time">get_frame_idx_at_time</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frame_list" href="#quetzal.dtos.video.Video.get_frame_list">get_frame_list</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frame_time" href="#quetzal.dtos.video.Video.get_frame_time">get_frame_time</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_raw_frame_at" href="#quetzal.dtos.video.Video.get_raw_frame_at">get_raw_frame_at</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_video_end_idx" href="#quetzal.dtos.video.Video.get_video_end_idx">get_video_end_idx</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_video_start_idx" href="#quetzal.dtos.video.Video.get_video_start_idx">get_video_start_idx</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.home" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.home">home</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.is_dir_valid" href="#quetzal.dtos.video.Video.is_dir_valid">is_dir_valid</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.iterdir" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.iterdir">iterdir</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.loadMetaData" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.loadMetaData">loadMetaData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.load_video_info" href="#quetzal.dtos.video.Video.load_video_info">load_video_info</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.mode" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.mode">mode</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.name" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.name">name</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.path" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.path">path</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.perform" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.perform">perform</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.permission" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.permission">permission</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.resolution" href="#quetzal.dtos.video.Video.resolution">resolution</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.set_video_end" href="#quetzal.dtos.video.Video.set_video_end">set_video_end</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.set_video_start" href="#quetzal.dtos.video.Video.set_video_start">set_video_start</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.type" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.type">type</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.user" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.user">user</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.video_type" href="#quetzal.dtos.video.Video.video_type">video_type</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.visibility" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.visibility">visibility</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="quetzal.dtos.video.Video"><code class="flex name class">
<span>class <span class="ident">Video</span></span>
</code></dt>
<dd>
<div class="desc"><p>Represents a video file within the Quetzal system, capable of processing drone footage.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt>video_type (Literal["database", "query"]): Specifies the type of the video, indicating</dt>
<dt>its role within the dataset as either a reference (database) or subject (query) video.</dt>
<dt><strong><code>fps</code></strong> :&ensp;<code>Fps</code></dt>
<dd>Frames per second at which the video is processed.</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>Resolution</code></dt>
<dd>Resolution at which the video frames are processed.</dd>
</dl>
<p>Initializes a Video object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>The path to the video file, relative to <code>root_dir</code>.</dd>
<dt><strong><code>root_dir</code></strong></dt>
<dd>The root directory for datasets.</dd>
<dt><strong><code>metadata_dir</code></strong></dt>
<dd>The root directory for metadata.</dd>
<dt><strong><code>user</code></strong></dt>
<dd>The user associated with the video file. Defaults to a guest user.</dd>
<dt><strong><code>home</code></strong></dt>
<dd>The base home directory path. Defaults to "./".</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Metadata associated with the video file.</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>The parent QuetzalFile object, if applicable.</dd>
<dt><strong><code>video_type</code></strong></dt>
<dd>The type of the video, either 'database' or 'query'. Defaults to 'query'.</dd>
<dt><strong><code>fps</code></strong></dt>
<dd>The frames per second at which the video is processed. Defaults to 2.</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>The resolution at which the video frames are processed. Defaults to 1024.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Video(QuetzalFile):
    &#34;&#34;&#34;
    Represents a video file within the Quetzal system, capable of processing drone footage.

    Attributes:
        video_type (Literal[&#34;database&#34;, &#34;query&#34;]): Specifies the type of the video, indicating
            its role within the dataset as either a reference (database) or subject (query) video.
        fps (Fps): Frames per second at which the video is processed.
        resolution (Resolution): Resolution at which the video frames are processed.
    &#34;&#34;&#34;
    
    FILE_DEFAULT_DESCRIPTION = &#34;Uploader::= default\nRecorded Date (MM/DD/YYYY)::= default\nTime-of-day::= default\nWeather Condition::= default\nDescription::= default&#34;
    FILE_DEFAULT_META = &#34;FileType::= file\nVisibility::= private\nPermission::= full_write\nAnalysisProgress::= none\nSpecificType::=Video\n&#34;
        
    def __init__(
        self,
        path: Union[str, Path],
        root_dir: Union[str, Path],
        metadata_dir: Union[str, Path],        
        user: str = None,
        home: Union[str, Path] = &#34;./&#34;,
        metadata = None,
        parent: &#39;QuetzalFile&#39; = None,
        video_type: Literal[&#34;database&#34;, &#34;query&#34;] = &#34;query&#34;,
        fps: Fps = 2,
        resolution: Resolution = 1024,
    ):
        &#34;&#34;&#34;
        Initializes a Video object.

        Args:
            path: The path to the video file, relative to `root_dir`.
            root_dir: The root directory for datasets.
            metadata_dir: The root directory for metadata.
            user: The user associated with the video file. Defaults to a guest user.
            home: The base home directory path. Defaults to &#34;./&#34;.
            metadata: Metadata associated with the video file.
            parent: The parent QuetzalFile object, if applicable.
            video_type: The type of the video, either &#39;database&#39; or &#39;query&#39;. Defaults to &#39;query&#39;.
            fps: The frames per second at which the video is processed. Defaults to 2.
            resolution: The resolution at which the video frames are processed. Defaults to 1024.
        &#34;&#34;&#34;
        super().__init__(
            path=path,
            root_dir=root_dir,
            metadata_dir=metadata_dir,
            user=user,
            home=home,
            metadata=metadata,
            parent=parent
        )
        
        assert video_type in [
            &#34;database&#34;,
            &#34;query&#34;,
        ], &#34;video_type must be &#39;database&#39; or &#39;query&#39;&#34;
        
        self._video_type = video_type
        self._fps = fps
        self._resolution = resolution
        
        self._gps = None
        self.logger = logging.getLogger(&#34;Video_&#34; + self._path.name)
        self.logger.setLevel(logging.DEBUG)
        self.debug = lambda *args: self.logger.debug(&#34; &#34;.join([str(arg) for arg in args]))

        self._lock = threading.RLock()
        self._cam = None
        self._native_fps = None
        self._orig_width, self._orig_height = None, None
        
        self._video_start = 0
        self._video_end = None
        
    
    def load_video_info(self):
        &#34;&#34;&#34;
        Loads video information such as native frames per second (fps), original width, and height from the video file. Initializes the video capture object.

        Raises:
            ValueError: If the video file cannot be opened.
        &#34;&#34;&#34;
        # Initialize the camera and check if it&#39;s a valid video file
        self._cam = cv2.VideoCapture(str(self.full_path))
        if not self._cam.isOpened():
            raise ValueError(f&#34;Failed to open video file: {self.full_path}&#34;)

        self._native_fps = self._cam.get(cv2.CAP_PROP_FPS)
        self._orig_width, self._orig_height = int(self._cam.get(3)), int(self._cam.get(4))
        
    @property
    def fps(self) -&gt; Fps:
        &#34;&#34;&#34;
        Gets the frames per second (fps) at which the video is processed.

        Returns:
            Fps: The current fps setting for video processing.
        &#34;&#34;&#34;
        return self._fps
    
    @fps.setter
    def fps(self, value: Fps):
        &#34;&#34;&#34;
        Sets the frames per second (fps) for video processing.

        Args:
            value (Fps): The new fps setting.
        &#34;&#34;&#34;
        self._fps = value
    
    @property
    def resolution(self) -&gt; Resolution:
        &#34;&#34;&#34;
        Gets the resolution at which the video frames are processed.

        Returns:
            Resolution: The current resolution setting for video processing.
        &#34;&#34;&#34;
        return self._resolution
    
    @resolution.setter
    def resolution(self, value: Resolution):
        &#34;&#34;&#34;
        Sets the resolution for video processing.

        Args:
            value (Resolution): The new resolution setting.
        &#34;&#34;&#34;
        self._resolution = value
    
    @property
    def video_type(self) -&gt; Literal[&#34;database&#34;, &#34;query&#34;] :
        &#34;&#34;&#34;
        Gets the type of the video, indicating whether it&#39;s used as reference (database) or subject (query).

        Returns:
            Literal[&#34;database&#34;, &#34;query&#34;]: The current video type setting.
        &#34;&#34;&#34;
        return self._video_type
    
    @video_type.setter
    def video_type(self, value: Literal[&#34;database&#34;, &#34;query&#34;] ):
        &#34;&#34;&#34;
        Sets the type of the video to either &#39;database&#39; or &#39;query&#39;.

        Args:
            value (Literal[&#34;database&#34;, &#34;query&#34;]): The new video type setting.
        &#34;&#34;&#34;
        self._video_type = value
        
    @property
    def _dataset_dir(self) -&gt; Path:
        &#34;&#34;&#34;
        Internal method to construct the dataset directory path based on the video type and file path.

        Returns:
            Path: The dataset directory path.
        &#34;&#34;&#34;
        if self._metadata_dir:
            return self._metadata_dir / self._path.parent / self._video_type / self._path.stem
        else:
            return self._root_dir / self._path.parent / self._video_type / self._path.stem
        
    @property
    def dataset_dir(self) -&gt; Path:
        &#34;&#34;&#34;
        Constructs the complete dataset directory path including frames configuration (fps and resolution).

        Returns:
            Path: The complete dataset directory path for storing frames.
        &#34;&#34;&#34;
        return self._dataset_dir / f&#34;frames_{self._fps}_{self._resolution}&#34;
    
    
    @property
    def avaliable_frames(self) -&gt; list[tuple[Fps, Resolution]]:
        &#34;&#34;&#34;
        Checks the availability of different combinations of fps and resolution for which the frames are extracted.

        Returns:
            list[tuple]: A list of tuples (fps, resolution) available in the dataset.
        &#34;&#34;&#34;
        dir_list = [
            d
            for d in os.listdir(self._dataset_dir)
            if os.path.isdir(join(self._dataset_dir, d))
        ]

        if len(dir_list) == 0:
            return []

        return [
            extract_fps_res(str(dir))
            for dir in dir_list
            if self.is_dir_valid(join(self._dataset_dir, dir))
        ]
    
    
    @property
    def frame_len(self) -&gt; int:
        &#34;&#34;&#34;
        Retrieves the total number of frames in the dataset directory.

        Returns:
            int: The number of frames, or -1 if the frame count is not available.
        &#34;&#34;&#34;

        target_dir = self.dataset_dir
        frame_count_file = join(target_dir, &#34;frame_counts.txt&#34;)

        with self._lock:
            if os.path.exists(frame_count_file):
                return frame_count(frame_count_file)
            else:
                return -1
    

    @staticmethod
    def get_frame_list(dir: str) -&gt; List[str]:
        &#34;&#34;&#34;
        Get a list of frame file paths from a directory.

        Args:
            dir (str): The directory to search for frame files.

        Returns:
            List[str]: A list of file paths for each frame in the directory.
        &#34;&#34;&#34;
        files = glob(join(dir, f&#34;frame*.jpg&#34;))
        pattern = re.compile(r&#34;frame(\d{5})\.jpg&#34;)
        return [f for f in files if pattern.search(f)]

    def get_frame_idx(self, frame_path: str) -&gt; int:
        &#34;&#34;&#34;
        Extracts the frame index from a frame file path.

        Args:
            frame_path (str): The file path of the frame.

        Returns:
            int: The index of the frame.
        &#34;&#34;&#34;

        frame_number_str = frame_path[-9:-4]  # Assuming 5-digit frame number
        return int(frame_number_str) - 1

    def get_frame_idx_at_time(self, frame_time: float) -&gt; int:
        &#34;&#34;&#34;
        Gets the frame index at a specific time in the video.

        Args:
            frame_time (float): The time in seconds.

        Returns:
            int: The frame index corresponding to the given time.
        &#34;&#34;&#34;
        return int(frame_time * self._fps + 0.5)

    def get_frame_time(self, frame_index: int) -&gt; float:
        &#34;&#34;&#34;
        Converts a frame index to a time point in the video.

        Args:
            frame_index (int): The index of the frame.

        Returns:
            float: Time in seconds where the frame is located in the video.
        &#34;&#34;&#34;
        return frame_index / self._fps

    def get_raw_frame_at(self, idx: int) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Retrieves the raw frame at a given index from the video.

        Args:
            idx (int): The frame index.

        Returns:
            ndarray: The raw frame as a numpy array in RGB format, or None if retrieval fails.
        &#34;&#34;&#34;
        if self._cam is None:
            self.load_video_info()

        orig_frame_idx = int(idx / self._fps * self._native_fps + 0.5)
        self._cam.set(cv2.CAP_PROP_POS_FRAMES, orig_frame_idx)
        rv, frame = self._cam.read()

        if rv:
            return cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        else:
            return None

    def set_video_start(self, minute: int, sec: int):
        &#34;&#34;&#34;
        Sets the starting point for video processing based on a specific time given in minutes and seconds.

        Args:
            minute (int): The starting minute in the video.
            sec (int): The starting second in the video.
        &#34;&#34;&#34;
        

        if not (minute &gt;= 0 and sec &gt;= 0):
            logging.error(&#34;Video-start should be positive time&#34;)
            return

        sec = 60 * minute + sec
        index = sec * self._fps
        self._video_start = index

    def set_video_end(self, minute: int, sec: int):
        &#34;&#34;&#34;
        Sets the ending point for video processing based on a specific time given in minutes and seconds.

        Args:
            minute (int): The ending minute in the video.
            sec (int): The ending second in the video.
        &#34;&#34;&#34;

        if not (minute &gt;= 0 and sec &gt;= 0):
            logging.error(&#34;Video-end should be positive time&#34;)
            return

        sec = 60 * minute + sec
        index = sec * self._fps
        if index &gt; self._video_start:
            self._video_end = index
        else:
            minute = int(self._video_start / self._fps / 60)
            sec = int(self._video_start / self._fps) % 60
            logging.error(
                f&#34;Video-end Should be greator than video-start = {minute}:{sec}&#34;
            )
            self._video_end = None

    def get_video_start_idx(self) -&gt; int:
        &#34;&#34;&#34;
        Gets the starting frame index of the video for processing.

        Returns:
            int: The starting frame index.
        &#34;&#34;&#34;
        return self._video_start

    def get_video_end_idx(self) -&gt; int:
        &#34;&#34;&#34;
        Gets the ending frame index of the video for processing.

        Returns:
            int: The ending frame index, or None if not set.
        &#34;&#34;&#34;
        return self._video_end


    def is_dir_valid(self, dir: Union[str, Path]) -&gt; bool:
        &#34;&#34;&#34;
        Validates if the specified directory contains a valid set of extracted frames and matches the recorded frame count.

        Args:
            dir (Union[str, Path]): The directory to validate.

        Returns:
            bool: True if the directory contains a valid set of frames, False otherwise.
        &#34;&#34;&#34;

        if not os.path.isdir(dir):
            return False

        frame_count_file = join(dir, &#34;frame_counts.txt&#34;)
        if os.path.exists(frame_count_file):
            if len(Video.get_frame_list(dir)) == frame_count(frame_count_file):
                return True
        return False

    def get_frames(self, verbose: bool = True) -&gt; List[str]:
        &#34;&#34;&#34;
        Retrieves or generates frames for the video at the current fps and resolution settings.

        Args:
            verbose (bool, optional): If True, logs additional information. Defaults to True.

        Returns:
            list: A list of frame file paths.
        &#34;&#34;&#34;

        fps = self._fps
        resolution = self._resolution

        target_dir = self.dataset_dir
        frame_count_file = target_dir / &#34;frame_counts.txt&#34;

        loaded = False
        with self._lock:
            if not self.is_dir_valid(target_dir):
                if verbose:
                    self.logger.info(
                        f&#34;Frames in fps={fps}, res={resolution} do not exist. Generating...&#34;
                    )
                os.makedirs(target_dir, exist_ok=True)
                input_frames = extract_frames(
                    self.full_path, target_dir, max_size=resolution, fps=fps
                )
                with open(frame_count_file, &#34;w&#34;) as f:
                    f.write(str(len(input_frames)))

                loaded = True

        if not loaded:
            if verbose:
                self.logger.info(
                    f&#34;Frames in fps={fps}, res={resolution} found in the dataset.&#34;
                )
            input_frames = Video.get_frame_list(target_dir)

        # self.frame_len = len(input_frames)
        idx_start = self._video_start
        if self._video_end == None:
            idx_end = len(input_frames)
        else:
            idx_end = self._video_end
        return natsort.natsorted(input_frames)[
            idx_start : min(idx_end, len(input_frames))
        ]    
        
    def _renameAnalysisData(self, newName: Path):
        &#34;&#34;&#34;
        Rename analysis data associated with the video, including updating paths of analysis data directories to reflect the new video name.

        Args:
            newName (Path): The new name for the video, used to update analysis data directories.
        &#34;&#34;&#34;
        for data_dir in reserved_names:
            analysis_path = (
                self._metadata_dir / self._path.parent / data_dir / self._path.stem
            )

            if analysis_path.exists():
                new_path = (
                    self._metadata_dir / self._path.parent / data_dir / newName.stem
                )
                os.rename(analysis_path, new_path)
    
    def _updateMetaForRename(self, new_path):
        &#34;&#34;&#34;
        Overrides the superclass method to update metadata and analysis data for the video in response to renaming. Ensures consistency between the video file&#39;s metadata and its analysis data following a name change.

        Args:
            new_path (Path): The new path for the video file, reflecting its new name.
        &#34;&#34;&#34;
        self._renameAnalysisData(new_path)
        super()._updateMetaForRename(new_path)
    
    
    def _deleteAnalysisData(self):
        &#34;&#34;&#34;
        Delete all analysis data associated with the video. Ensures that orphaned analysis data is removed when a video file is deleted from the system.
        &#34;&#34;&#34;
        for data_dir in [DATABASE_ROOT, QUERY_ROOT]:
            analysis_path = (
                self._metadata_dir / self._path.parent / data_dir / self._path.stem
            )

            if analysis_path.exists():
                shutil.rmtree(analysis_path)
                
    def _updateMetaForDelete(self):
        &#34;&#34;&#34;
        Overrides the superclass method to update the video&#39;s metadata to reflect its deletion, including removing all references to the video and its analysis data.
        &#34;&#34;&#34;
        self._deleteAnalysisData()
        super()._updateMetaForDelete()
        
    
    def _copyAnalysisData(self, newDir: Path, destName: Path, move=False):
        &#34;&#34;&#34;
        Copy or move the analysis data associated with the video. Supports video copy or move operations by maintaining the integrity of analysis data.

        Args:
            newDir (Path): Directory to which the analysis data will be copied or moved.
            destName (Path): Name of the destination directory or file.
            move (bool, optional): If True, analysis data is moved; otherwise, it is copied. Defaults to False.
        &#34;&#34;&#34;
        
        for data_dir in [&#34;database&#34;, &#34;query&#34;]:
            analysis_path = (
                self._metadata_dir / self._path.parent / data_dir / self._path.stem
            )
            if analysis_path.exists():
                copy_path = self._metadata_dir / newDir / data_dir / destName.stem
                if move:
                    shutil.move(analysis_path, copy_path)
                else:
                    shutil.copytree(analysis_path, copy_path)
    
    def _updateMetaForCopy(self, dest: Path):
        &#34;&#34;&#34;
        Overrides the superclass method to update metadata for a video after copying. Includes copying the analysis data to the new location and updating the video&#39;s metadata.

        Args:
            dest (Path): Destination path where the video and its analysis data have been copied.
        &#34;&#34;&#34;
        super()._updateMetaForCopy(dest)
        self._copyAnalysisData(dest.parent, Path(dest.name))
        
    
    def _updateMetaForMove(self, dest_dir: Path):
        &#34;&#34;&#34;
        Overrides the superclass method to update metadata for a video after moving. Manages relocation of analysis data and updates the video&#39;s metadata to reflect the move.

        Args:
            dest_dir (Path): Destination directory to which the video and its analysis data have been moved.
        &#34;&#34;&#34;
        super()._updateMetaForMove(dest_dir)
        self._copyAnalysisData(dest_dir, Path(self._path.name), move=True)


    def _syncAnalysisState(self, engine=&#34;vpr_engine.anyloc_engine.AnyLocEngine&#34;):
        &#34;&#34;&#34;
        Overrides to synchronize the video&#39;s analysis state with a specified analysis engine. Updates the video&#39;s metadata to reflect current analysis state.

        Args:
            engine (str, optional): Qualified class name of the analysis engine for state checking. Defaults to &#34;vpr_engine.anyloc_engine.AnyLocEngine&#34;.

        Raises:
            ValueError: If the analysis engine cannot be found or initialized.
        &#34;&#34;&#34;
        assert self._type == FileType.FILE
        # from quetzal.engines.vpr_engine.anyloc_engine import AnyLocEngine
        
        module_path, class_name = engine.rsplit(&#34;.&#34;, 1)
        if module_path:
            module = importlib.import_module(f&#34;quetzal.engines.{module_path}&#34;)
            engine_class: AbstractEngine = getattr(module, class_name)
        
        if engine_class is None:
            raise ValueError(&#34;Engine Definition Not Found&#34;)
        
        video = DatabaseVideo(
            path=self._path,
            root_dir=self._root_dir,
            metadata_dir=self._metadata_dir,
            user=self._user,
            home=self._home,
        )
            
        if engine_class.is_video_analyzed(video):
            self._updateMetaForAnalyze(new_progress=AnalysisProgress.FULL)
            self._analysis_progress = AnalysisProgress.FULL
            return

        video = QueryVideo(
            path=self._path,
            root_dir=self._root_dir,
            metadata_dir=self._metadata_dir,
            user=self._user,
            home=self._home,
        )

        if engine_class.is_video_analyzed(video):
            self._updateMetaForAnalyze(new_progress=AnalysisProgress.HALF)
            self._analysis_progress = AnalysisProgress.HALF
            return

        self._updateMetaForAnalyze(new_progress=AnalysisProgress.NONE)
        self._analysis_progress = AnalysisProgress.NONE
        return


    def _analyze(self, option: AnalysisProgress, engine=&#34;vpr_engine.anyloc_engine.AnyLocEngine&#34;, device=torch.device(&#34;cuda:0&#34;)):
        &#34;&#34;&#34;
        Overrides to analyze the video based on a specified level of analysis progress, using an analysis engine and device. Updates the video&#39;s analysis state and metadata upon completion.

        Args:
            option (AnalysisProgress): Desired analysis level.
            engine (str, optional): Qualified class name of the analysis engine. Defaults to &#34;vpr_engine.anyloc_engine.AnyLocEngine&#34;.
            device (torch.device, optional): Computing device for analysis. Defaults to &#34;cuda:0&#34;.

        Returns:
            str: Message indicating analysis completion.
        &#34;&#34;&#34;
        assert (
            self._mode == AccessMode.OWNER or self._permission != Permission.READ_ONLY
        )
        self.debug(f&#34;\n\t{self.name} called on analyze {option}\n&#34;)
        
        if option == None:
            return None

        self.debug(&#34;I am here&#34;)

        self._syncAnalysisState(engine)
        if self._analysis_progress &gt;= option:
            return None
        
        module_path, class_name = engine.rsplit(&#34;.&#34;, 1)
        if module_path:
            module = importlib.import_module(f&#34;quetzal.engines.{module_path}&#34;)
            engine_class: AbstractEngine = getattr(module, class_name)
        
        if engine_class is None:
            raise ValueError(&#34;Engine Definition Not Found&#34;)
        
        self.debug(engine_class)
                
        if option == AnalysisProgress.FULL:
            video = DatabaseVideo(
                path=self._path,
                root_dir=self._root_dir,
                metadata_dir=self._metadata_dir,
                user=self._user,
                home=self._home,
            )
        if option == AnalysisProgress.HALF:
            video = QueryVideo(
                path=self._path,
                root_dir=self._root_dir,
                metadata_dir=self._metadata_dir,
                user=self._user,
                home=self._home,
            )
            
        engine_class(device = device).analyze_video(video)

        self._updateMetaForAnalyze(new_progress=option)
        self._analysis_progress = option
        
        return f&#39;&#34;{self.name}&#34; Analysis Done&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="quetzal.dtos.dtos.QuetzalFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="quetzal.dtos.video.DatabaseVideo" href="#quetzal.dtos.video.DatabaseVideo">DatabaseVideo</a></li>
<li><a title="quetzal.dtos.video.LiveQueryVideo" href="#quetzal.dtos.video.LiveQueryVideo">LiveQueryVideo</a></li>
<li><a title="quetzal.dtos.video.QueryVideo" href="#quetzal.dtos.video.QueryVideo">QueryVideo</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="quetzal.dtos.video.Video.FILE_DEFAULT_DESCRIPTION"><code class="name">var <span class="ident">FILE_DEFAULT_DESCRIPTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="quetzal.dtos.video.Video.FILE_DEFAULT_META"><code class="name">var <span class="ident">FILE_DEFAULT_META</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="quetzal.dtos.video.Video.get_frame_list"><code class="name flex">
<span>def <span class="ident">get_frame_list</span></span>(<span>dir: str) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of frame file paths from a directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dir</code></strong> :&ensp;<code>str</code></dt>
<dd>The directory to search for frame files.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>A list of file paths for each frame in the directory.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_frame_list(dir: str) -&gt; List[str]:
    &#34;&#34;&#34;
    Get a list of frame file paths from a directory.

    Args:
        dir (str): The directory to search for frame files.

    Returns:
        List[str]: A list of file paths for each frame in the directory.
    &#34;&#34;&#34;
    files = glob(join(dir, f&#34;frame*.jpg&#34;))
    pattern = re.compile(r&#34;frame(\d{5})\.jpg&#34;)
    return [f for f in files if pattern.search(f)]</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="quetzal.dtos.video.Video._dataset_dir"><code class="name">var <span class="ident">_dataset_dir</span> : pathlib.Path</code></dt>
<dd>
<div class="desc"><p>Internal method to construct the dataset directory path based on the video type and file path.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Path</code></dt>
<dd>The dataset directory path.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def _dataset_dir(self) -&gt; Path:
    &#34;&#34;&#34;
    Internal method to construct the dataset directory path based on the video type and file path.

    Returns:
        Path: The dataset directory path.
    &#34;&#34;&#34;
    if self._metadata_dir:
        return self._metadata_dir / self._path.parent / self._video_type / self._path.stem
    else:
        return self._root_dir / self._path.parent / self._video_type / self._path.stem</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video.avaliable_frames"><code class="name">var <span class="ident">avaliable_frames</span> : list[tuple[quetzal.dtos.video.Fps, quetzal.dtos.video.Resolution]]</code></dt>
<dd>
<div class="desc"><p>Checks the availability of different combinations of fps and resolution for which the frames are extracted.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[tuple]</code></dt>
<dd>A list of tuples (fps, resolution) available in the dataset.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def avaliable_frames(self) -&gt; list[tuple[Fps, Resolution]]:
    &#34;&#34;&#34;
    Checks the availability of different combinations of fps and resolution for which the frames are extracted.

    Returns:
        list[tuple]: A list of tuples (fps, resolution) available in the dataset.
    &#34;&#34;&#34;
    dir_list = [
        d
        for d in os.listdir(self._dataset_dir)
        if os.path.isdir(join(self._dataset_dir, d))
    ]

    if len(dir_list) == 0:
        return []

    return [
        extract_fps_res(str(dir))
        for dir in dir_list
        if self.is_dir_valid(join(self._dataset_dir, dir))
    ]</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video.dataset_dir"><code class="name">var <span class="ident">dataset_dir</span> : pathlib.Path</code></dt>
<dd>
<div class="desc"><p>Constructs the complete dataset directory path including frames configuration (fps and resolution).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Path</code></dt>
<dd>The complete dataset directory path for storing frames.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dataset_dir(self) -&gt; Path:
    &#34;&#34;&#34;
    Constructs the complete dataset directory path including frames configuration (fps and resolution).

    Returns:
        Path: The complete dataset directory path for storing frames.
    &#34;&#34;&#34;
    return self._dataset_dir / f&#34;frames_{self._fps}_{self._resolution}&#34;</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video.fps"><code class="name">var <span class="ident">fps</span> : quetzal.dtos.video.Fps</code></dt>
<dd>
<div class="desc"><p>Gets the frames per second (fps) at which the video is processed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Fps</code></dt>
<dd>The current fps setting for video processing.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fps(self) -&gt; Fps:
    &#34;&#34;&#34;
    Gets the frames per second (fps) at which the video is processed.

    Returns:
        Fps: The current fps setting for video processing.
    &#34;&#34;&#34;
    return self._fps</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video.frame_len"><code class="name">var <span class="ident">frame_len</span> : int</code></dt>
<dd>
<div class="desc"><p>Retrieves the total number of frames in the dataset directory.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of frames, or -1 if the frame count is not available.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frame_len(self) -&gt; int:
    &#34;&#34;&#34;
    Retrieves the total number of frames in the dataset directory.

    Returns:
        int: The number of frames, or -1 if the frame count is not available.
    &#34;&#34;&#34;

    target_dir = self.dataset_dir
    frame_count_file = join(target_dir, &#34;frame_counts.txt&#34;)

    with self._lock:
        if os.path.exists(frame_count_file):
            return frame_count(frame_count_file)
        else:
            return -1</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video.resolution"><code class="name">var <span class="ident">resolution</span> : quetzal.dtos.video.Resolution</code></dt>
<dd>
<div class="desc"><p>Gets the resolution at which the video frames are processed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Resolution</code></dt>
<dd>The current resolution setting for video processing.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resolution(self) -&gt; Resolution:
    &#34;&#34;&#34;
    Gets the resolution at which the video frames are processed.

    Returns:
        Resolution: The current resolution setting for video processing.
    &#34;&#34;&#34;
    return self._resolution</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video.video_type"><code class="name">var <span class="ident">video_type</span> : Literal['database', 'query']</code></dt>
<dd>
<div class="desc"><p>Gets the type of the video, indicating whether it's used as reference (database) or subject (query).</p>
<h2 id="returns">Returns</h2>
<p>Literal["database", "query"]: The current video type setting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def video_type(self) -&gt; Literal[&#34;database&#34;, &#34;query&#34;] :
    &#34;&#34;&#34;
    Gets the type of the video, indicating whether it&#39;s used as reference (database) or subject (query).

    Returns:
        Literal[&#34;database&#34;, &#34;query&#34;]: The current video type setting.
    &#34;&#34;&#34;
    return self._video_type</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="quetzal.dtos.video.Video.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, path: Union[str, pathlib.Path], root_dir: Union[str, pathlib.Path], metadata_dir: Union[str, pathlib.Path], user: str = None, home: Union[str, pathlib.Path] = './', metadata=None, parent: QuetzalFile = None, video_type: Literal['database', 'query'] = 'query', fps: quetzal.dtos.video.Fps = 2, resolution: quetzal.dtos.video.Resolution = 1024)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a Video object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>The path to the video file, relative to <code>root_dir</code>.</dd>
<dt><strong><code>root_dir</code></strong></dt>
<dd>The root directory for datasets.</dd>
<dt><strong><code>metadata_dir</code></strong></dt>
<dd>The root directory for metadata.</dd>
<dt><strong><code>user</code></strong></dt>
<dd>The user associated with the video file. Defaults to a guest user.</dd>
<dt><strong><code>home</code></strong></dt>
<dd>The base home directory path. Defaults to "./".</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>Metadata associated with the video file.</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>The parent QuetzalFile object, if applicable.</dd>
<dt><strong><code>video_type</code></strong></dt>
<dd>The type of the video, either 'database' or 'query'. Defaults to 'query'.</dd>
<dt><strong><code>fps</code></strong></dt>
<dd>The frames per second at which the video is processed. Defaults to 2.</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>The resolution at which the video frames are processed. Defaults to 1024.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __init__(
    self,
    path: Union[str, Path],
    root_dir: Union[str, Path],
    metadata_dir: Union[str, Path],        
    user: str = None,
    home: Union[str, Path] = &#34;./&#34;,
    metadata = None,
    parent: &#39;QuetzalFile&#39; = None,
    video_type: Literal[&#34;database&#34;, &#34;query&#34;] = &#34;query&#34;,
    fps: Fps = 2,
    resolution: Resolution = 1024,
):
    &#34;&#34;&#34;
    Initializes a Video object.

    Args:
        path: The path to the video file, relative to `root_dir`.
        root_dir: The root directory for datasets.
        metadata_dir: The root directory for metadata.
        user: The user associated with the video file. Defaults to a guest user.
        home: The base home directory path. Defaults to &#34;./&#34;.
        metadata: Metadata associated with the video file.
        parent: The parent QuetzalFile object, if applicable.
        video_type: The type of the video, either &#39;database&#39; or &#39;query&#39;. Defaults to &#39;query&#39;.
        fps: The frames per second at which the video is processed. Defaults to 2.
        resolution: The resolution at which the video frames are processed. Defaults to 1024.
    &#34;&#34;&#34;
    super().__init__(
        path=path,
        root_dir=root_dir,
        metadata_dir=metadata_dir,
        user=user,
        home=home,
        metadata=metadata,
        parent=parent
    )
    
    assert video_type in [
        &#34;database&#34;,
        &#34;query&#34;,
    ], &#34;video_type must be &#39;database&#39; or &#39;query&#39;&#34;
    
    self._video_type = video_type
    self._fps = fps
    self._resolution = resolution
    
    self._gps = None
    self.logger = logging.getLogger(&#34;Video_&#34; + self._path.name)
    self.logger.setLevel(logging.DEBUG)
    self.debug = lambda *args: self.logger.debug(&#34; &#34;.join([str(arg) for arg in args]))

    self._lock = threading.RLock()
    self._cam = None
    self._native_fps = None
    self._orig_width, self._orig_height = None, None
    
    self._video_start = 0
    self._video_end = None</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video._analyze"><code class="name flex">
<span>def <span class="ident">_analyze</span></span>(<span>self, option: <a title="quetzal.dtos.dtos.AnalysisProgress" href="dtos.html#quetzal.dtos.dtos.AnalysisProgress">AnalysisProgress</a>, engine='vpr_engine.anyloc_engine.AnyLocEngine', device=device(type='cuda', index=0))</span>
</code></dt>
<dd>
<div class="desc"><p>Overrides to analyze the video based on a specified level of analysis progress, using an analysis engine and device. Updates the video's analysis state and metadata upon completion.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>option</code></strong> :&ensp;<code>AnalysisProgress</code></dt>
<dd>Desired analysis level.</dd>
<dt><strong><code>engine</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Qualified class name of the analysis engine. Defaults to "vpr_engine.anyloc_engine.AnyLocEngine".</dd>
<dt><strong><code>device</code></strong> :&ensp;<code>torch.device</code>, optional</dt>
<dd>Computing device for analysis. Defaults to "cuda:0".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Message indicating analysis completion.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _analyze(self, option: AnalysisProgress, engine=&#34;vpr_engine.anyloc_engine.AnyLocEngine&#34;, device=torch.device(&#34;cuda:0&#34;)):
    &#34;&#34;&#34;
    Overrides to analyze the video based on a specified level of analysis progress, using an analysis engine and device. Updates the video&#39;s analysis state and metadata upon completion.

    Args:
        option (AnalysisProgress): Desired analysis level.
        engine (str, optional): Qualified class name of the analysis engine. Defaults to &#34;vpr_engine.anyloc_engine.AnyLocEngine&#34;.
        device (torch.device, optional): Computing device for analysis. Defaults to &#34;cuda:0&#34;.

    Returns:
        str: Message indicating analysis completion.
    &#34;&#34;&#34;
    assert (
        self._mode == AccessMode.OWNER or self._permission != Permission.READ_ONLY
    )
    self.debug(f&#34;\n\t{self.name} called on analyze {option}\n&#34;)
    
    if option == None:
        return None

    self.debug(&#34;I am here&#34;)

    self._syncAnalysisState(engine)
    if self._analysis_progress &gt;= option:
        return None
    
    module_path, class_name = engine.rsplit(&#34;.&#34;, 1)
    if module_path:
        module = importlib.import_module(f&#34;quetzal.engines.{module_path}&#34;)
        engine_class: AbstractEngine = getattr(module, class_name)
    
    if engine_class is None:
        raise ValueError(&#34;Engine Definition Not Found&#34;)
    
    self.debug(engine_class)
            
    if option == AnalysisProgress.FULL:
        video = DatabaseVideo(
            path=self._path,
            root_dir=self._root_dir,
            metadata_dir=self._metadata_dir,
            user=self._user,
            home=self._home,
        )
    if option == AnalysisProgress.HALF:
        video = QueryVideo(
            path=self._path,
            root_dir=self._root_dir,
            metadata_dir=self._metadata_dir,
            user=self._user,
            home=self._home,
        )
        
    engine_class(device = device).analyze_video(video)

    self._updateMetaForAnalyze(new_progress=option)
    self._analysis_progress = option
    
    return f&#39;&#34;{self.name}&#34; Analysis Done&#39;</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video._copyAnalysisData"><code class="name flex">
<span>def <span class="ident">_copyAnalysisData</span></span>(<span>self, newDir: pathlib.Path, destName: pathlib.Path, move=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy or move the analysis data associated with the video. Supports video copy or move operations by maintaining the integrity of analysis data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>newDir</code></strong> :&ensp;<code>Path</code></dt>
<dd>Directory to which the analysis data will be copied or moved.</dd>
<dt><strong><code>destName</code></strong> :&ensp;<code>Path</code></dt>
<dd>Name of the destination directory or file.</dd>
<dt><strong><code>move</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, analysis data is moved; otherwise, it is copied. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _copyAnalysisData(self, newDir: Path, destName: Path, move=False):
    &#34;&#34;&#34;
    Copy or move the analysis data associated with the video. Supports video copy or move operations by maintaining the integrity of analysis data.

    Args:
        newDir (Path): Directory to which the analysis data will be copied or moved.
        destName (Path): Name of the destination directory or file.
        move (bool, optional): If True, analysis data is moved; otherwise, it is copied. Defaults to False.
    &#34;&#34;&#34;
    
    for data_dir in [&#34;database&#34;, &#34;query&#34;]:
        analysis_path = (
            self._metadata_dir / self._path.parent / data_dir / self._path.stem
        )
        if analysis_path.exists():
            copy_path = self._metadata_dir / newDir / data_dir / destName.stem
            if move:
                shutil.move(analysis_path, copy_path)
            else:
                shutil.copytree(analysis_path, copy_path)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video._deleteAnalysisData"><code class="name flex">
<span>def <span class="ident">_deleteAnalysisData</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete all analysis data associated with the video. Ensures that orphaned analysis data is removed when a video file is deleted from the system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _deleteAnalysisData(self):
    &#34;&#34;&#34;
    Delete all analysis data associated with the video. Ensures that orphaned analysis data is removed when a video file is deleted from the system.
    &#34;&#34;&#34;
    for data_dir in [DATABASE_ROOT, QUERY_ROOT]:
        analysis_path = (
            self._metadata_dir / self._path.parent / data_dir / self._path.stem
        )

        if analysis_path.exists():
            shutil.rmtree(analysis_path)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video._renameAnalysisData"><code class="name flex">
<span>def <span class="ident">_renameAnalysisData</span></span>(<span>self, newName: pathlib.Path)</span>
</code></dt>
<dd>
<div class="desc"><p>Rename analysis data associated with the video, including updating paths of analysis data directories to reflect the new video name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>newName</code></strong> :&ensp;<code>Path</code></dt>
<dd>The new name for the video, used to update analysis data directories.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _renameAnalysisData(self, newName: Path):
    &#34;&#34;&#34;
    Rename analysis data associated with the video, including updating paths of analysis data directories to reflect the new video name.

    Args:
        newName (Path): The new name for the video, used to update analysis data directories.
    &#34;&#34;&#34;
    for data_dir in reserved_names:
        analysis_path = (
            self._metadata_dir / self._path.parent / data_dir / self._path.stem
        )

        if analysis_path.exists():
            new_path = (
                self._metadata_dir / self._path.parent / data_dir / newName.stem
            )
            os.rename(analysis_path, new_path)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video._syncAnalysisState"><code class="name flex">
<span>def <span class="ident">_syncAnalysisState</span></span>(<span>self, engine='vpr_engine.anyloc_engine.AnyLocEngine')</span>
</code></dt>
<dd>
<div class="desc"><p>Overrides to synchronize the video's analysis state with a specified analysis engine. Updates the video's metadata to reflect current analysis state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>engine</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Qualified class name of the analysis engine for state checking. Defaults to "vpr_engine.anyloc_engine.AnyLocEngine".</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the analysis engine cannot be found or initialized.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _syncAnalysisState(self, engine=&#34;vpr_engine.anyloc_engine.AnyLocEngine&#34;):
    &#34;&#34;&#34;
    Overrides to synchronize the video&#39;s analysis state with a specified analysis engine. Updates the video&#39;s metadata to reflect current analysis state.

    Args:
        engine (str, optional): Qualified class name of the analysis engine for state checking. Defaults to &#34;vpr_engine.anyloc_engine.AnyLocEngine&#34;.

    Raises:
        ValueError: If the analysis engine cannot be found or initialized.
    &#34;&#34;&#34;
    assert self._type == FileType.FILE
    # from quetzal.engines.vpr_engine.anyloc_engine import AnyLocEngine
    
    module_path, class_name = engine.rsplit(&#34;.&#34;, 1)
    if module_path:
        module = importlib.import_module(f&#34;quetzal.engines.{module_path}&#34;)
        engine_class: AbstractEngine = getattr(module, class_name)
    
    if engine_class is None:
        raise ValueError(&#34;Engine Definition Not Found&#34;)
    
    video = DatabaseVideo(
        path=self._path,
        root_dir=self._root_dir,
        metadata_dir=self._metadata_dir,
        user=self._user,
        home=self._home,
    )
        
    if engine_class.is_video_analyzed(video):
        self._updateMetaForAnalyze(new_progress=AnalysisProgress.FULL)
        self._analysis_progress = AnalysisProgress.FULL
        return

    video = QueryVideo(
        path=self._path,
        root_dir=self._root_dir,
        metadata_dir=self._metadata_dir,
        user=self._user,
        home=self._home,
    )

    if engine_class.is_video_analyzed(video):
        self._updateMetaForAnalyze(new_progress=AnalysisProgress.HALF)
        self._analysis_progress = AnalysisProgress.HALF
        return

    self._updateMetaForAnalyze(new_progress=AnalysisProgress.NONE)
    self._analysis_progress = AnalysisProgress.NONE
    return</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video._updateMetaForCopy"><code class="name flex">
<span>def <span class="ident">_updateMetaForCopy</span></span>(<span>self, dest: pathlib.Path)</span>
</code></dt>
<dd>
<div class="desc"><p>Overrides the superclass method to update metadata for a video after copying. Includes copying the analysis data to the new location and updating the video's metadata.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dest</code></strong> :&ensp;<code>Path</code></dt>
<dd>Destination path where the video and its analysis data have been copied.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _updateMetaForCopy(self, dest: Path):
    &#34;&#34;&#34;
    Overrides the superclass method to update metadata for a video after copying. Includes copying the analysis data to the new location and updating the video&#39;s metadata.

    Args:
        dest (Path): Destination path where the video and its analysis data have been copied.
    &#34;&#34;&#34;
    super()._updateMetaForCopy(dest)
    self._copyAnalysisData(dest.parent, Path(dest.name))</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video._updateMetaForDelete"><code class="name flex">
<span>def <span class="ident">_updateMetaForDelete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Overrides the superclass method to update the video's metadata to reflect its deletion, including removing all references to the video and its analysis data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _updateMetaForDelete(self):
    &#34;&#34;&#34;
    Overrides the superclass method to update the video&#39;s metadata to reflect its deletion, including removing all references to the video and its analysis data.
    &#34;&#34;&#34;
    self._deleteAnalysisData()
    super()._updateMetaForDelete()</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video._updateMetaForMove"><code class="name flex">
<span>def <span class="ident">_updateMetaForMove</span></span>(<span>self, dest_dir: pathlib.Path)</span>
</code></dt>
<dd>
<div class="desc"><p>Overrides the superclass method to update metadata for a video after moving. Manages relocation of analysis data and updates the video's metadata to reflect the move.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dest_dir</code></strong> :&ensp;<code>Path</code></dt>
<dd>Destination directory to which the video and its analysis data have been moved.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _updateMetaForMove(self, dest_dir: Path):
    &#34;&#34;&#34;
    Overrides the superclass method to update metadata for a video after moving. Manages relocation of analysis data and updates the video&#39;s metadata to reflect the move.

    Args:
        dest_dir (Path): Destination directory to which the video and its analysis data have been moved.
    &#34;&#34;&#34;
    super()._updateMetaForMove(dest_dir)
    self._copyAnalysisData(dest_dir, Path(self._path.name), move=True)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video._updateMetaForRename"><code class="name flex">
<span>def <span class="ident">_updateMetaForRename</span></span>(<span>self, new_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Overrides the superclass method to update metadata and analysis data for the video in response to renaming. Ensures consistency between the video file's metadata and its analysis data following a name change.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_path</code></strong> :&ensp;<code>Path</code></dt>
<dd>The new path for the video file, reflecting its new name.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _updateMetaForRename(self, new_path):
    &#34;&#34;&#34;
    Overrides the superclass method to update metadata and analysis data for the video in response to renaming. Ensures consistency between the video file&#39;s metadata and its analysis data following a name change.

    Args:
        new_path (Path): The new path for the video file, reflecting its new name.
    &#34;&#34;&#34;
    self._renameAnalysisData(new_path)
    super()._updateMetaForRename(new_path)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video.get_frame_idx"><code class="name flex">
<span>def <span class="ident">get_frame_idx</span></span>(<span>self, frame_path: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts the frame index from a frame file path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>frame_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The file path of the frame.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The index of the frame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frame_idx(self, frame_path: str) -&gt; int:
    &#34;&#34;&#34;
    Extracts the frame index from a frame file path.

    Args:
        frame_path (str): The file path of the frame.

    Returns:
        int: The index of the frame.
    &#34;&#34;&#34;

    frame_number_str = frame_path[-9:-4]  # Assuming 5-digit frame number
    return int(frame_number_str) - 1</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video.get_frame_idx_at_time"><code class="name flex">
<span>def <span class="ident">get_frame_idx_at_time</span></span>(<span>self, frame_time: float) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the frame index at a specific time in the video.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>frame_time</code></strong> :&ensp;<code>float</code></dt>
<dd>The time in seconds.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The frame index corresponding to the given time.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frame_idx_at_time(self, frame_time: float) -&gt; int:
    &#34;&#34;&#34;
    Gets the frame index at a specific time in the video.

    Args:
        frame_time (float): The time in seconds.

    Returns:
        int: The frame index corresponding to the given time.
    &#34;&#34;&#34;
    return int(frame_time * self._fps + 0.5)</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video.get_frame_time"><code class="name flex">
<span>def <span class="ident">get_frame_time</span></span>(<span>self, frame_index: int) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a frame index to a time point in the video.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>frame_index</code></strong> :&ensp;<code>int</code></dt>
<dd>The index of the frame.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Time in seconds where the frame is located in the video.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frame_time(self, frame_index: int) -&gt; float:
    &#34;&#34;&#34;
    Converts a frame index to a time point in the video.

    Args:
        frame_index (int): The index of the frame.

    Returns:
        float: Time in seconds where the frame is located in the video.
    &#34;&#34;&#34;
    return frame_index / self._fps</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video.get_frames"><code class="name flex">
<span>def <span class="ident">get_frames</span></span>(<span>self, verbose: bool = True) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves or generates frames for the video at the current fps and resolution settings.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, logs additional information. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of frame file paths.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frames(self, verbose: bool = True) -&gt; List[str]:
    &#34;&#34;&#34;
    Retrieves or generates frames for the video at the current fps and resolution settings.

    Args:
        verbose (bool, optional): If True, logs additional information. Defaults to True.

    Returns:
        list: A list of frame file paths.
    &#34;&#34;&#34;

    fps = self._fps
    resolution = self._resolution

    target_dir = self.dataset_dir
    frame_count_file = target_dir / &#34;frame_counts.txt&#34;

    loaded = False
    with self._lock:
        if not self.is_dir_valid(target_dir):
            if verbose:
                self.logger.info(
                    f&#34;Frames in fps={fps}, res={resolution} do not exist. Generating...&#34;
                )
            os.makedirs(target_dir, exist_ok=True)
            input_frames = extract_frames(
                self.full_path, target_dir, max_size=resolution, fps=fps
            )
            with open(frame_count_file, &#34;w&#34;) as f:
                f.write(str(len(input_frames)))

            loaded = True

    if not loaded:
        if verbose:
            self.logger.info(
                f&#34;Frames in fps={fps}, res={resolution} found in the dataset.&#34;
            )
        input_frames = Video.get_frame_list(target_dir)

    # self.frame_len = len(input_frames)
    idx_start = self._video_start
    if self._video_end == None:
        idx_end = len(input_frames)
    else:
        idx_end = self._video_end
    return natsort.natsorted(input_frames)[
        idx_start : min(idx_end, len(input_frames))
    ]    </code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video.get_raw_frame_at"><code class="name flex">
<span>def <span class="ident">get_raw_frame_at</span></span>(<span>self, idx: int) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the raw frame at a given index from the video.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>The frame index.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>The raw frame as a numpy array in RGB format, or None if retrieval fails.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_raw_frame_at(self, idx: int) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Retrieves the raw frame at a given index from the video.

    Args:
        idx (int): The frame index.

    Returns:
        ndarray: The raw frame as a numpy array in RGB format, or None if retrieval fails.
    &#34;&#34;&#34;
    if self._cam is None:
        self.load_video_info()

    orig_frame_idx = int(idx / self._fps * self._native_fps + 0.5)
    self._cam.set(cv2.CAP_PROP_POS_FRAMES, orig_frame_idx)
    rv, frame = self._cam.read()

    if rv:
        return cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video.get_video_end_idx"><code class="name flex">
<span>def <span class="ident">get_video_end_idx</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the ending frame index of the video for processing.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The ending frame index, or None if not set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_video_end_idx(self) -&gt; int:
    &#34;&#34;&#34;
    Gets the ending frame index of the video for processing.

    Returns:
        int: The ending frame index, or None if not set.
    &#34;&#34;&#34;
    return self._video_end</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video.get_video_start_idx"><code class="name flex">
<span>def <span class="ident">get_video_start_idx</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the starting frame index of the video for processing.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The starting frame index.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_video_start_idx(self) -&gt; int:
    &#34;&#34;&#34;
    Gets the starting frame index of the video for processing.

    Returns:
        int: The starting frame index.
    &#34;&#34;&#34;
    return self._video_start</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video.is_dir_valid"><code class="name flex">
<span>def <span class="ident">is_dir_valid</span></span>(<span>self, dir: Union[str, pathlib.Path]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Validates if the specified directory contains a valid set of extracted frames and matches the recorded frame count.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dir</code></strong> :&ensp;<code>Union[str, Path]</code></dt>
<dd>The directory to validate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the directory contains a valid set of frames, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_dir_valid(self, dir: Union[str, Path]) -&gt; bool:
    &#34;&#34;&#34;
    Validates if the specified directory contains a valid set of extracted frames and matches the recorded frame count.

    Args:
        dir (Union[str, Path]): The directory to validate.

    Returns:
        bool: True if the directory contains a valid set of frames, False otherwise.
    &#34;&#34;&#34;

    if not os.path.isdir(dir):
        return False

    frame_count_file = join(dir, &#34;frame_counts.txt&#34;)
    if os.path.exists(frame_count_file):
        if len(Video.get_frame_list(dir)) == frame_count(frame_count_file):
            return True
    return False</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video.load_video_info"><code class="name flex">
<span>def <span class="ident">load_video_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads video information such as native frames per second (fps), original width, and height from the video file. Initializes the video capture object.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the video file cannot be opened.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_video_info(self):
    &#34;&#34;&#34;
    Loads video information such as native frames per second (fps), original width, and height from the video file. Initializes the video capture object.

    Raises:
        ValueError: If the video file cannot be opened.
    &#34;&#34;&#34;
    # Initialize the camera and check if it&#39;s a valid video file
    self._cam = cv2.VideoCapture(str(self.full_path))
    if not self._cam.isOpened():
        raise ValueError(f&#34;Failed to open video file: {self.full_path}&#34;)

    self._native_fps = self._cam.get(cv2.CAP_PROP_FPS)
    self._orig_width, self._orig_height = int(self._cam.get(3)), int(self._cam.get(4))</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video.set_video_end"><code class="name flex">
<span>def <span class="ident">set_video_end</span></span>(<span>self, minute: int, sec: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the ending point for video processing based on a specific time given in minutes and seconds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>minute</code></strong> :&ensp;<code>int</code></dt>
<dd>The ending minute in the video.</dd>
<dt><strong><code>sec</code></strong> :&ensp;<code>int</code></dt>
<dd>The ending second in the video.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_video_end(self, minute: int, sec: int):
    &#34;&#34;&#34;
    Sets the ending point for video processing based on a specific time given in minutes and seconds.

    Args:
        minute (int): The ending minute in the video.
        sec (int): The ending second in the video.
    &#34;&#34;&#34;

    if not (minute &gt;= 0 and sec &gt;= 0):
        logging.error(&#34;Video-end should be positive time&#34;)
        return

    sec = 60 * minute + sec
    index = sec * self._fps
    if index &gt; self._video_start:
        self._video_end = index
    else:
        minute = int(self._video_start / self._fps / 60)
        sec = int(self._video_start / self._fps) % 60
        logging.error(
            f&#34;Video-end Should be greator than video-start = {minute}:{sec}&#34;
        )
        self._video_end = None</code></pre>
</details>
</dd>
<dt id="quetzal.dtos.video.Video.set_video_start"><code class="name flex">
<span>def <span class="ident">set_video_start</span></span>(<span>self, minute: int, sec: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the starting point for video processing based on a specific time given in minutes and seconds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>minute</code></strong> :&ensp;<code>int</code></dt>
<dd>The starting minute in the video.</dd>
<dt><strong><code>sec</code></strong> :&ensp;<code>int</code></dt>
<dd>The starting second in the video.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_video_start(self, minute: int, sec: int):
    &#34;&#34;&#34;
    Sets the starting point for video processing based on a specific time given in minutes and seconds.

    Args:
        minute (int): The starting minute in the video.
        sec (int): The starting second in the video.
    &#34;&#34;&#34;
    

    if not (minute &gt;= 0 and sec &gt;= 0):
        logging.error(&#34;Video-start should be positive time&#34;)
        return

    sec = 60 * minute + sec
    index = sec * self._fps
    self._video_start = index</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="quetzal.dtos.dtos.QuetzalFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile">QuetzalFile</a></b></code>:
<ul class="hlist">
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.__eq__" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.__eq__">__eq__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.__format__" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.__format__">__format__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.__hash__" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.__hash__">__hash__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.__repr__" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.__repr__">__repr__</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._abs_path" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._abs_path">_abs_path</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._copy" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._copy">_copy</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._delete" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._delete">_delete</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._editDescription" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._editDescription">_editDescription</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._getDescriptionPath" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._getDescriptionPath">_getDescriptionPath</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._getMetaDataPath" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._getMetaDataPath">_getMetaDataPath</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._instantiateFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._instantiateFile">_instantiateFile</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._loadMetaData" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._loadMetaData">_loadMetaData</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._makeDefaultDescription" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._makeDefaultDescription">_makeDefaultDescription</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._move" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._move">_move</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._newDirectory" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._newDirectory">_newDirectory</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._parseMetadata" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._parseMetadata">_parseMetadata</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._rename" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._rename">_rename</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._share" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._share">_share</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._updateMetaForAnalyze" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._updateMetaForAnalyze">_updateMetaForAnalyze</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._updateMetaForNewFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._updateMetaForNewFile">_updateMetaForNewFile</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._updateMetaForShare" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._updateMetaForShare">_updateMetaForShare</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile._upload" href="dtos.html#quetzal.dtos.dtos.QuetzalFile._upload">_upload</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.analysis_progress" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.analysis_progress">analysis_progress</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.createdBy" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.createdBy">createdBy</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.fromFile" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.fromFile">fromFile</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.full_path" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.full_path">full_path</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.getDescription" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.getDescription">getDescription</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.getDescriptionPath" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.getDescriptionPath">getDescriptionPath</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.getMetaDataPath" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.getMetaDataPath">getMetaDataPath</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.home" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.home">home</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.iterdir" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.iterdir">iterdir</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.loadMetaData" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.loadMetaData">loadMetaData</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.mode" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.mode">mode</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.name" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.name">name</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.path" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.path">path</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.perform" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.perform">perform</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.permission" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.permission">permission</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.type" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.type">type</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.user" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.user">user</a></code></li>
<li><code><a title="quetzal.dtos.dtos.QuetzalFile.visibility" href="dtos.html#quetzal.dtos.dtos.QuetzalFile.visibility">visibility</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="quetzal.dtos" href="index.html">quetzal.dtos</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="quetzal.dtos.video.extract_fps_res" href="#quetzal.dtos.video.extract_fps_res">extract_fps_res</a></code></li>
<li><code><a title="quetzal.dtos.video.frame_count" href="#quetzal.dtos.video.frame_count">frame_count</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="quetzal.dtos.video.DatabaseVideo" href="#quetzal.dtos.video.DatabaseVideo">DatabaseVideo</a></code></h4>
<ul class="">
<li><code><a title="quetzal.dtos.video.DatabaseVideo.FPS" href="#quetzal.dtos.video.DatabaseVideo.FPS">FPS</a></code></li>
<li><code><a title="quetzal.dtos.video.DatabaseVideo.RESOLUTION" href="#quetzal.dtos.video.DatabaseVideo.RESOLUTION">RESOLUTION</a></code></li>
<li><code><a title="quetzal.dtos.video.DatabaseVideo.__init__" href="#quetzal.dtos.video.DatabaseVideo.__init__">__init__</a></code></li>
<li><code><a title="quetzal.dtos.video.DatabaseVideo.from_quetzal_file" href="#quetzal.dtos.video.DatabaseVideo.from_quetzal_file">from_quetzal_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="quetzal.dtos.video.LiveQueryVideo" href="#quetzal.dtos.video.LiveQueryVideo">LiveQueryVideo</a></code></h4>
</li>
<li>
<h4><code><a title="quetzal.dtos.video.QueryVideo" href="#quetzal.dtos.video.QueryVideo">QueryVideo</a></code></h4>
<ul class="">
<li><code><a title="quetzal.dtos.video.QueryVideo.FPS" href="#quetzal.dtos.video.QueryVideo.FPS">FPS</a></code></li>
<li><code><a title="quetzal.dtos.video.QueryVideo.RESOLUTION" href="#quetzal.dtos.video.QueryVideo.RESOLUTION">RESOLUTION</a></code></li>
<li><code><a title="quetzal.dtos.video.QueryVideo.__init__" href="#quetzal.dtos.video.QueryVideo.__init__">__init__</a></code></li>
<li><code><a title="quetzal.dtos.video.QueryVideo._convert_from_database" href="#quetzal.dtos.video.QueryVideo._convert_from_database">_convert_from_database</a></code></li>
<li><code><a title="quetzal.dtos.video.QueryVideo.from_quetzal_file" href="#quetzal.dtos.video.QueryVideo.from_quetzal_file">from_quetzal_file</a></code></li>
<li><code><a title="quetzal.dtos.video.QueryVideo.get_frames" href="#quetzal.dtos.video.QueryVideo.get_frames">get_frames</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="quetzal.dtos.video.Video" href="#quetzal.dtos.video.Video">Video</a></code></h4>
<ul class="">
<li><code><a title="quetzal.dtos.video.Video.FILE_DEFAULT_DESCRIPTION" href="#quetzal.dtos.video.Video.FILE_DEFAULT_DESCRIPTION">FILE_DEFAULT_DESCRIPTION</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.FILE_DEFAULT_META" href="#quetzal.dtos.video.Video.FILE_DEFAULT_META">FILE_DEFAULT_META</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.__init__" href="#quetzal.dtos.video.Video.__init__">__init__</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._analyze" href="#quetzal.dtos.video.Video._analyze">_analyze</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._copyAnalysisData" href="#quetzal.dtos.video.Video._copyAnalysisData">_copyAnalysisData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._dataset_dir" href="#quetzal.dtos.video.Video._dataset_dir">_dataset_dir</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._deleteAnalysisData" href="#quetzal.dtos.video.Video._deleteAnalysisData">_deleteAnalysisData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._renameAnalysisData" href="#quetzal.dtos.video.Video._renameAnalysisData">_renameAnalysisData</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._syncAnalysisState" href="#quetzal.dtos.video.Video._syncAnalysisState">_syncAnalysisState</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForCopy" href="#quetzal.dtos.video.Video._updateMetaForCopy">_updateMetaForCopy</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForDelete" href="#quetzal.dtos.video.Video._updateMetaForDelete">_updateMetaForDelete</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForMove" href="#quetzal.dtos.video.Video._updateMetaForMove">_updateMetaForMove</a></code></li>
<li><code><a title="quetzal.dtos.video.Video._updateMetaForRename" href="#quetzal.dtos.video.Video._updateMetaForRename">_updateMetaForRename</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.avaliable_frames" href="#quetzal.dtos.video.Video.avaliable_frames">avaliable_frames</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.dataset_dir" href="#quetzal.dtos.video.Video.dataset_dir">dataset_dir</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.fps" href="#quetzal.dtos.video.Video.fps">fps</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.frame_len" href="#quetzal.dtos.video.Video.frame_len">frame_len</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frame_idx" href="#quetzal.dtos.video.Video.get_frame_idx">get_frame_idx</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frame_idx_at_time" href="#quetzal.dtos.video.Video.get_frame_idx_at_time">get_frame_idx_at_time</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frame_list" href="#quetzal.dtos.video.Video.get_frame_list">get_frame_list</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frame_time" href="#quetzal.dtos.video.Video.get_frame_time">get_frame_time</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_frames" href="#quetzal.dtos.video.Video.get_frames">get_frames</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_raw_frame_at" href="#quetzal.dtos.video.Video.get_raw_frame_at">get_raw_frame_at</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_video_end_idx" href="#quetzal.dtos.video.Video.get_video_end_idx">get_video_end_idx</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.get_video_start_idx" href="#quetzal.dtos.video.Video.get_video_start_idx">get_video_start_idx</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.is_dir_valid" href="#quetzal.dtos.video.Video.is_dir_valid">is_dir_valid</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.load_video_info" href="#quetzal.dtos.video.Video.load_video_info">load_video_info</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.resolution" href="#quetzal.dtos.video.Video.resolution">resolution</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.set_video_end" href="#quetzal.dtos.video.Video.set_video_end">set_video_end</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.set_video_start" href="#quetzal.dtos.video.Video.set_video_start">set_video_start</a></code></li>
<li><code><a title="quetzal.dtos.video.Video.video_type" href="#quetzal.dtos.video.Video.video_type">video_type</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>