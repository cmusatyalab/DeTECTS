<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>quetzal.utils.video_tools API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>quetzal.utils.video_tools</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import copy
import os
import re
import subprocess
from glob import glob
from os.path import join
from typing import List


import cv2
import gradio as gr
import numpy as np
import utm
from tqdm import tqdm


### Video Frame Extract
def extract_frames(
    video_path: str, output_dir: str, fps: int = 2, max_size=-1, interpolation=&#34;bicubic&#34;
) -&gt; List[str]:
    &#34;&#34;&#34;
    Extract frames from a video at a specified frame rate and scale them to a maximum size.

    Args:
    video_path (str): Path to the video file.
    output_dir (str): Directory where the extracted frames will be saved.
    fps (int): Frame rate for extraction. Default is 2.
    max_size (int, optional): Maximum size (width or height) for the extracted frames. Default is -1 (no scaling).
    interpolation (str, optional): Interpolation method used for scaling. Default is &#39;bicubic&#39;. It can be &#39;lanczos&#39;, &#39;bicubic&#39;, or any ffmpeg scaler options.

    Returns:
    list: List of file paths for the extracted frames.
    &#34;&#34;&#34;

    if not max_size:
        max_size = -1

    # Use the &#39;scale&#39; filter to set the width or height to &#39;max_size&#39;, while preserving the aspect ratio.
    scale_filter = f&#34;scale=&#39;if(gt(iw,ih),{max_size},-1)&#39;:&#39;if(gt(iw,ih),-1,{max_size})&#39;:flags={interpolation}&#34;

    # Construct the ffmpeg command with both the &#39;fps&#39; and &#39;scale&#39; filters.
    command = [
        &#34;ffmpeg&#34;,
        &#34;-i&#34;,
        video_path,
        &#34;-qscale:v&#34;,
        &#34;2&#34;,
        &#34;-vf&#34;,
        f&#34;{scale_filter},fps={fps}&#34;,
        f&#34;{output_dir}/frame%05d.jpg&#34;,
    ]
    subprocess.run(command, capture_output=True)

    return glob(join(output_dir, &#34;*.jpg&#34;))


def dms_to_decimal(dms_str: str) -&gt; str:
    &#34;&#34;&#34;
    Convert a string from DMS (Degrees, Minutes, Seconds) format to decimal format.

    Args:
    dms_str (str): A string representing coordinates in DMS format.

    Returns:
    str: The converted coordinate in decimal format.
    &#34;&#34;&#34;
    # Extract degrees, minutes, and seconds using regex
    match = re.match(r&#34;(-?\d+) deg (\d+)&#34; + r&#34;&#39; &#34; + r&#39;([\d.]+)&#34;&#39;, dms_str)
    if not match:
        raise ValueError(f&#34;Invalid DMS format: {dms_str}&#34;)

    degrees, minutes, seconds = map(float, match.groups())
    is_negative = degrees &lt; 0 or &#34;S&#34; in dms_str or &#34;W&#34; in dms_str
    decimal_degrees = abs(degrees) + (minutes / 60) + (seconds / 3600)
    result = -decimal_degrees if is_negative else decimal_degrees

    return f&#34;{result:3.5f}&#34;


def parse_exiftool_output(output: str) -&gt; List[str]:
    &#34;&#34;&#34;
    Parse &#39;TimeStamp&#39;, &#39;Latitude&#39;, &#39;Longitude&#39;, and &#39;Elevation&#39; from exiftool output from Anafi Ai Video footage

    Args:
    output (str): The output string from exiftool.

    Returns:
    list: A list of dictionaries with frame information.
    &#34;&#34;&#34;
    frames = []
    frame = {}
    for line in output.splitlines():
        if &#34;Sample Time&#34; in line and frame:
            frames.append(frame)
            frame = {}
            time = line.split(&#34;:&#34;)[1].strip()
            frame[&#34;TimeStamp&#34;] = time
        if &#34;GPS Latitude&#34; in line:
            lat_dms = line.split(&#34;:&#34;)[1].strip()
            frame[&#34;Latitude&#34;] = dms_to_decimal(lat_dms)
        if &#34;GPS Longitude&#34; in line:
            lon_dms = line.split(&#34;:&#34;)[1].strip()
            frame[&#34;Longitude&#34;] = dms_to_decimal(lon_dms)
        if &#34;Elevation&#34; in line:
            frame[&#34;Elevation&#34;] = line.split(&#34;:&#34;)[1].strip()
    if frame:
        frames.append(frame)
    return frames


def extract_gps_for_frames(video_path: str, output_directory: str) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Extract GPS information for frames in a given directory based on exiftool output from a video.

    Args:
    video_path (str): Path to the video file.
    output_directory (str): Directory where the frames are stored.

    Returns:
    numpy.ndarray: An array containing GPS coordinates (UTM Easting and Northing) for each frame.
    &#34;&#34;&#34;

    # Step 1: Extract exiftool output
    command = [&#34;exiftool&#34;, &#34;-ee&#34;, video_path]
    result = subprocess.run(command, capture_output=True, text=True)
    assert result.returncode != 1, result.stderr
    gps_frames = parse_exiftool_output(result.stdout)
    img_frames = glob(join(output_directory, &#34;*.jpg&#34;))

    # Step 3: Obtain GPS value (UTM Easting, UTM Northing) for each img_frames
    num_frames = len(img_frames)

    # Align the GPS index to the extracted frame&#39;s index
    step = int(len(gps_frames) / len(img_frames) + 0.5)
    gps_frame_idx = list(range(0, len(gps_frames), step))
    diff = num_frames - len(gps_frame_idx)
    while diff &gt; 0:
        gps_frame_idx.append(gps_frame_idx[-1])
        diff = diff - 1

    db_gps = np.zeros((num_frames, 2))
    for index, img_frame in enumerate(img_frames):
        latitude = gps_frames[gps_frame_idx[index]].get(&#34;Latitude&#34;)
        longitude = gps_frames[gps_frame_idx[index]].get(&#34;Longitude&#34;)
        easting, northing, _zone_number, _zone_letter = utm.from_latlon(
            float(latitude), float(longitude)
        )
        db_gps[index] = [easting, northing]

    return db_gps


def assert_absolute_path(file_path: str):
    assert os.path.isabs(file_path), f&#34;&#39;{file_path}&#39; is not an absolute path&#34;


if __name__ == &#34;__main__&#34;:
    from tqdm import tqdm

    max_size = 1024
    database_video = &#34;P0190019.MP4&#34;
    query_video = &#34;P0200020.MP4&#34;

    # Configure folders
    datasets_folder = join(os.curdir, &#34;AnyLoc&#34;, &#34;datasets_vg&#34;, &#34;datasets&#34;)
    dataset_name = &#34;mil19_1fps&#34;
    dataset_folder = join(datasets_folder, dataset_name)

    raw_data_folder = join(datasets_folder, dataset_name, &#34;raw_video&#34;)
    os.makedirs(dataset_folder, exist_ok=True)
    os.makedirs(raw_data_folder, exist_ok=True)
    os.makedirs(join(dataset_folder, &#34;images&#34;, &#34;test&#34;), exist_ok=True)

    dst_database_folder = join(dataset_folder, &#34;images&#34;, &#34;test&#34;, &#34;database&#34;)
    os.makedirs(dst_database_folder, exist_ok=True)
    dst_queries_folder = join(dataset_folder, &#34;images&#34;, &#34;test&#34;, &#34;queries&#34;)
    os.makedirs(dst_queries_folder, exist_ok=True)

    db_video_path = join(raw_data_folder, database_video)
    query_video_path = join(raw_data_folder, query_video)
    print(db_video_path)
    print(dst_database_folder)

    img_frames = glob(join(dst_database_folder, &#34;*.jpg&#34;))
    print(img_frames)

    for i in tqdm([1]):
        if len(glob(join(dst_database_folder, &#34;*.jpg&#34;))) == 0:
            input_frames = extract_frames(
                db_video_path, dst_database_folder, max_size=1024, fps=6
            )
            db_gps = extract_gps_for_frames(db_video_path, dst_database_folder)
            np.save(f&#34;{dataset_folder}/db_gps.npy&#34;, db_gps)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="quetzal.utils.video_tools.assert_absolute_path"><code class="name flex">
<span>def <span class="ident">assert_absolute_path</span></span>(<span>file_path: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_absolute_path(file_path: str):
    assert os.path.isabs(file_path), f&#34;&#39;{file_path}&#39; is not an absolute path&#34;</code></pre>
</details>
</dd>
<dt id="quetzal.utils.video_tools.dms_to_decimal"><code class="name flex">
<span>def <span class="ident">dms_to_decimal</span></span>(<span>dms_str: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a string from DMS (Degrees, Minutes, Seconds) format to decimal format.</p>
<p>Args:
dms_str (str): A string representing coordinates in DMS format.</p>
<p>Returns:
str: The converted coordinate in decimal format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dms_to_decimal(dms_str: str) -&gt; str:
    &#34;&#34;&#34;
    Convert a string from DMS (Degrees, Minutes, Seconds) format to decimal format.

    Args:
    dms_str (str): A string representing coordinates in DMS format.

    Returns:
    str: The converted coordinate in decimal format.
    &#34;&#34;&#34;
    # Extract degrees, minutes, and seconds using regex
    match = re.match(r&#34;(-?\d+) deg (\d+)&#34; + r&#34;&#39; &#34; + r&#39;([\d.]+)&#34;&#39;, dms_str)
    if not match:
        raise ValueError(f&#34;Invalid DMS format: {dms_str}&#34;)

    degrees, minutes, seconds = map(float, match.groups())
    is_negative = degrees &lt; 0 or &#34;S&#34; in dms_str or &#34;W&#34; in dms_str
    decimal_degrees = abs(degrees) + (minutes / 60) + (seconds / 3600)
    result = -decimal_degrees if is_negative else decimal_degrees

    return f&#34;{result:3.5f}&#34;</code></pre>
</details>
</dd>
<dt id="quetzal.utils.video_tools.extract_frames"><code class="name flex">
<span>def <span class="ident">extract_frames</span></span>(<span>video_path: str, output_dir: str, fps: int = 2, max_size=-1, interpolation='bicubic') ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Extract frames from a video at a specified frame rate and scale them to a maximum size.</p>
<p>Args:
video_path (str): Path to the video file.
output_dir (str): Directory where the extracted frames will be saved.
fps (int): Frame rate for extraction. Default is 2.
max_size (int, optional): Maximum size (width or height) for the extracted frames. Default is -1 (no scaling).
interpolation (str, optional): Interpolation method used for scaling. Default is 'bicubic'. It can be 'lanczos', 'bicubic', or any ffmpeg scaler options.</p>
<p>Returns:
list: List of file paths for the extracted frames.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_frames(
    video_path: str, output_dir: str, fps: int = 2, max_size=-1, interpolation=&#34;bicubic&#34;
) -&gt; List[str]:
    &#34;&#34;&#34;
    Extract frames from a video at a specified frame rate and scale them to a maximum size.

    Args:
    video_path (str): Path to the video file.
    output_dir (str): Directory where the extracted frames will be saved.
    fps (int): Frame rate for extraction. Default is 2.
    max_size (int, optional): Maximum size (width or height) for the extracted frames. Default is -1 (no scaling).
    interpolation (str, optional): Interpolation method used for scaling. Default is &#39;bicubic&#39;. It can be &#39;lanczos&#39;, &#39;bicubic&#39;, or any ffmpeg scaler options.

    Returns:
    list: List of file paths for the extracted frames.
    &#34;&#34;&#34;

    if not max_size:
        max_size = -1

    # Use the &#39;scale&#39; filter to set the width or height to &#39;max_size&#39;, while preserving the aspect ratio.
    scale_filter = f&#34;scale=&#39;if(gt(iw,ih),{max_size},-1)&#39;:&#39;if(gt(iw,ih),-1,{max_size})&#39;:flags={interpolation}&#34;

    # Construct the ffmpeg command with both the &#39;fps&#39; and &#39;scale&#39; filters.
    command = [
        &#34;ffmpeg&#34;,
        &#34;-i&#34;,
        video_path,
        &#34;-qscale:v&#34;,
        &#34;2&#34;,
        &#34;-vf&#34;,
        f&#34;{scale_filter},fps={fps}&#34;,
        f&#34;{output_dir}/frame%05d.jpg&#34;,
    ]
    subprocess.run(command, capture_output=True)

    return glob(join(output_dir, &#34;*.jpg&#34;))</code></pre>
</details>
</dd>
<dt id="quetzal.utils.video_tools.extract_gps_for_frames"><code class="name flex">
<span>def <span class="ident">extract_gps_for_frames</span></span>(<span>video_path: str, output_directory: str) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Extract GPS information for frames in a given directory based on exiftool output from a video.</p>
<p>Args:
video_path (str): Path to the video file.
output_directory (str): Directory where the frames are stored.</p>
<p>Returns:
numpy.ndarray: An array containing GPS coordinates (UTM Easting and Northing) for each frame.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_gps_for_frames(video_path: str, output_directory: str) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Extract GPS information for frames in a given directory based on exiftool output from a video.

    Args:
    video_path (str): Path to the video file.
    output_directory (str): Directory where the frames are stored.

    Returns:
    numpy.ndarray: An array containing GPS coordinates (UTM Easting and Northing) for each frame.
    &#34;&#34;&#34;

    # Step 1: Extract exiftool output
    command = [&#34;exiftool&#34;, &#34;-ee&#34;, video_path]
    result = subprocess.run(command, capture_output=True, text=True)
    assert result.returncode != 1, result.stderr
    gps_frames = parse_exiftool_output(result.stdout)
    img_frames = glob(join(output_directory, &#34;*.jpg&#34;))

    # Step 3: Obtain GPS value (UTM Easting, UTM Northing) for each img_frames
    num_frames = len(img_frames)

    # Align the GPS index to the extracted frame&#39;s index
    step = int(len(gps_frames) / len(img_frames) + 0.5)
    gps_frame_idx = list(range(0, len(gps_frames), step))
    diff = num_frames - len(gps_frame_idx)
    while diff &gt; 0:
        gps_frame_idx.append(gps_frame_idx[-1])
        diff = diff - 1

    db_gps = np.zeros((num_frames, 2))
    for index, img_frame in enumerate(img_frames):
        latitude = gps_frames[gps_frame_idx[index]].get(&#34;Latitude&#34;)
        longitude = gps_frames[gps_frame_idx[index]].get(&#34;Longitude&#34;)
        easting, northing, _zone_number, _zone_letter = utm.from_latlon(
            float(latitude), float(longitude)
        )
        db_gps[index] = [easting, northing]

    return db_gps</code></pre>
</details>
</dd>
<dt id="quetzal.utils.video_tools.parse_exiftool_output"><code class="name flex">
<span>def <span class="ident">parse_exiftool_output</span></span>(<span>output: str) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse 'TimeStamp', 'Latitude', 'Longitude', and 'Elevation' from exiftool output from Anafi Ai Video footage</p>
<p>Args:
output (str): The output string from exiftool.</p>
<p>Returns:
list: A list of dictionaries with frame information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_exiftool_output(output: str) -&gt; List[str]:
    &#34;&#34;&#34;
    Parse &#39;TimeStamp&#39;, &#39;Latitude&#39;, &#39;Longitude&#39;, and &#39;Elevation&#39; from exiftool output from Anafi Ai Video footage

    Args:
    output (str): The output string from exiftool.

    Returns:
    list: A list of dictionaries with frame information.
    &#34;&#34;&#34;
    frames = []
    frame = {}
    for line in output.splitlines():
        if &#34;Sample Time&#34; in line and frame:
            frames.append(frame)
            frame = {}
            time = line.split(&#34;:&#34;)[1].strip()
            frame[&#34;TimeStamp&#34;] = time
        if &#34;GPS Latitude&#34; in line:
            lat_dms = line.split(&#34;:&#34;)[1].strip()
            frame[&#34;Latitude&#34;] = dms_to_decimal(lat_dms)
        if &#34;GPS Longitude&#34; in line:
            lon_dms = line.split(&#34;:&#34;)[1].strip()
            frame[&#34;Longitude&#34;] = dms_to_decimal(lon_dms)
        if &#34;Elevation&#34; in line:
            frame[&#34;Elevation&#34;] = line.split(&#34;:&#34;)[1].strip()
    if frame:
        frames.append(frame)
    return frames</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="quetzal.utils" href="index.html">quetzal.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="quetzal.utils.video_tools.assert_absolute_path" href="#quetzal.utils.video_tools.assert_absolute_path">assert_absolute_path</a></code></li>
<li><code><a title="quetzal.utils.video_tools.dms_to_decimal" href="#quetzal.utils.video_tools.dms_to_decimal">dms_to_decimal</a></code></li>
<li><code><a title="quetzal.utils.video_tools.extract_frames" href="#quetzal.utils.video_tools.extract_frames">extract_frames</a></code></li>
<li><code><a title="quetzal.utils.video_tools.extract_gps_for_frames" href="#quetzal.utils.video_tools.extract_gps_for_frames">extract_gps_for_frames</a></code></li>
<li><code><a title="quetzal.utils.video_tools.parse_exiftool_output" href="#quetzal.utils.video_tools.parse_exiftool_output">parse_exiftool_output</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>